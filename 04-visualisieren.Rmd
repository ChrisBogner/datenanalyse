# Daten visualisieren {#visualisieren}

```{block, type = 'rmdoutcomes'}
- Einfache Grafiken erstellen
- Grafiken beschriften und speichern
- Die Arbeitsweise der Funktion `par` beschreiben
- Die grafischen Parameter für Randgröße, Farbe, Schrift- und Symbolgröße einstellen
- Unterschiede zwischen *high-level* und *low-level* Grafikfunktionen erklären
- Grafiken mit mehreren Plots erstellen
```

## Plotten mit R-Basisfunktionen

Für Grafikverliebte und Neugierige empfehle ich die Kapitel 2 und 3 in @Murrell2006.

### *High-level* Grafikfunktion `plot` und *low-level* Grafikfunktion `lines`

Ein Streudiagramm stellt zwei numerische Variablen gegeneinander dar. Wir betrachten Klimadaten der Station Köln-Bonn, die man beim Deutschen Wetterdienst herunterladen kann (https://www.dwd.de/DE/leistungen/klimadatendeutschland/klimadatendeutschland.html).

Sie können den Code aus den Chunks leicht herauskopieren und in RStudio laufen lassen (rechts oben in den Chunks auf das Symbol *copy to clipboard* klicken).


Wir lesen die Daten ein und sehen uns deren Struktur an.
```{r}
meteo <- read.table('produkt_klima_monat_20181001_20200430_02667.txt',
header = T, sep = ';')
str(meteo)
```


Uns interessieren hier nur die Spalten MO_TT, MO_TN, MO_TX und MESS_DATUM_BEGINN. Das sind jeweils die Monatsmittel der Lufttemperatur in 2 m Höhe, Monatsmittel des Minimums der Lufttemperatur, Monatsmittel des Maximums der Lufttemperatur und der Beginn der jeweiligen Messperiode (d.h. des Kalendermonats). Um die Daten als Zeitreihen darstellen zu können, wandeln wir die Spalte MESS_DATUM_BEGINN in ein richtiges Zeitobjekt (d.h. ein Objekt der Klasse *Date*). Das geht mit der Funktion `as.Date`. Der Parameter `format` beschreibt den Aufbau des Datums im Objekt `meteo`: erst steht das Jahr mit 4 Zeichen (z.B. 2018), dann folgt der Monat mit 2 Zeichen (z.B. 01) und dann der Tag mit 2 Zeichen (z.B. 01). Näheres zu Datumsformaten finden Sie mit `?strptime`.


```{r}
my_date <- as.Date(as.character(meteo$MESS_DATUM_BEGINN), format = '%Y%m%d')
my_date
```

Es sind Daten von Oktober 2018 bis April 2020. Wir erstellen ein Streudiagramm mit der Funktion `plot`. Mit den Parametern `xlab` und `ylab` lassen sich die beiden Achsen beschriften und `main` fügt einen Titel dazu. Der Parameter `type` bestimmt die Wahl der Symbole; hier benutzen wir `type = b` für *both*, also sowohl Punkte als auch Linien.

```{r}
plot(my_date, meteo$MO_TT, type = 'b', xlab = 'Zeit', ylab = 'Temperatur [°C]', main = 'Klimadaten der DWD-Station Köln-Bonn')
```


Die Funktion `plot` ist eine sogen. *high-level* Grafikfunktion. Das bedeutet, dass sie alle Schritte des Plottens übernimmt: sie öffnet ein neues Grafikfenster (ein Device), berechnet die Größe der Plotfläche und der Ränder (s. unten), berechnet die Ausdehnung der Achsen und die beste Achseneinteilung und plottet Ihre Daten.

Daneben gibt es *low-level* Grafikfunktionen, die nur in ein bestehendes Device plotten können. Wir wollen zu unserer Grafik nun die Minimum- und die Maximumtemperatur dazu plotten.

```{r}
plot(my_date, meteo$MO_TT, type = 'b', xlab = 'Zeit', ylab = 'Temperatur [°C]', main = 'Klimadaten der DWD-Station Köln-Bonn')

# Minimumtemperatur in blau
lines(my_date, meteo$MO_TN, col = 'blue')

# Maximumtemperatur in rot
lines(my_date, meteo$MO_TX, col = 'red')
```

Dass `lines` nur eine *low-level* Grafikfunktion ist, erkennen Sie daran, dass sie nicht in der Lage ist, den Bereich auf der y-Achse zu vergrößern, um alle Daten sichtbar zu machen. Das kann nur `plot`. Daher muss der Bereich bereits in `plot` richtig festgelegt werden. Das macht der Parameter `ylim`.

```{r}
plot(my_date, meteo$MO_TT, type = 'b', xlab = 'Zeit', ylab = 'Temperatur [°C]', main = 'Klimadaten der DWD-Station Köln-Bonn', ylim = c(0, 30))

# Minimumtemperatur in rot
lines(my_date, meteo$MO_TN, col = 'blue')

# Maximumtemperatur in blau
lines(my_date, meteo$MO_TX, col = 'red')
```

Wenn in einer Grafik mehrere Elemente dargestellt werden, benötigt man eine Legende. Das erledigt die * low-level* Grafikfunktion `legend`. 

```{r}
plot(my_date, meteo$MO_TT, type = 'b', xlab = 'Zeit', ylab = 'Temperatur [°C]', main = 'Klimadaten der DWD-Station Köln-Bonn', ylim = c(0, 30))

# Minimumtemperatur in rot
lines(my_date, meteo$MO_TN, col = 'blue')

# Maximumtemperatur in blau
lines(my_date, meteo$MO_TX, col = 'red')

legend('topright', legend = c('Mittelwert', 'Minimum', 'Maximum'),
       col = c('black', 'red', 'blue'), 
       pch = c(1, NA, NA),
       lty = 1)
```

Der Parameter `lty` steht für *line type* und die 1 bedeutet durchgezogene Linie. Mit `pch` legend wir die Art des Symbols fest; hier steht die 1 für das Standardsymbol "offener Kreis". Die Funktion `legend` hat viele Möglichkeiten und es lohnt sich, in die Hilfe zu sehen `?legend`.

### Überblick über die wichtigsten *high-level* und *low-level* Grafikfunktionen

Die wichtigsten *high-level* Grafikfunktionen nach @Ligges2008, verändert:

Funktion | Beschreibung |
:-------- | :------------ |
`plot` | kontextabhängig – generische Funktion mit vielen Methoden |
`barplot` | Säulendiagramm |
`boxplot` | Boxplot |
`contour` | Höhenlinien-Plot |
`coplot` | Conditioning-Plots: Plots zweier Variablen aufgeteilt nach Werten einer dritten |
`curve` | Funktionen zeichnen |
`dotchart` | Dotplots (nach Cleveland) |
`hist` | Histogramm |
`image` |Bilder (3. Dimension als Farbe) |
`mosaicplot`| Mosaikplots (kategorielle Daten) |
`pairs` |Streudiagramm-Matrix |
`persp` |perspektivische Flächen |
`qqnorm` und `qqplot` | QQ–Plot |


Die wichtigsten *low-level* Grafikfunktionen nach @Ligges2008, verändert:

Funktion | Beschreibung |
:-------- | :------------ |
`abline` | Fügt eine Linie hinzu; diese kann horizontal, vertikal oder über Steigung und Achsenabschnitt definiert werden |
`arrows` | Pfeile| 
`axis` | Achsen|
`grid` |Gitternetz|
`legend` |Legende|
`lines` |Linien (schrittweise)|
`mtext` |Text in den Rändern|
`plot.new` |Grafik initialisieren|
`plot.window` |Koordinatensystem initialisieren|
`points` | Punkte|
`polygon` |(ausgefüllte) Polygone|
`pretty` |berechnet "hübsche" Einteilung der Achsen|
`segments` |Linien (vektorwertig)|
`text` |Text|
`title` |Beschriftung|

## Tuning mit `par`

Zur Vertiefung dieses Kapitels, empfehle ich @Ligges2008, Kapitel 8.1.3. <br>

Die Grafikebene in R ist aufgeteilt in drei Regionen (Abbildung \@ref(fig:aufteilung)) und hat innere und äußere Ränder. Die Ränder werden von unten im Gegenuhrzeigersinn durchnummeriert.

```{r aufteilung, echo = F, fig.cap = 'Aufteilung der Grafikfläche [@Ligges2008].', fig.width = 6, out.width = "80%"}
knitr::include_graphics('Regionen_und_Raender.png', auto_pdf = T)
```

Mit der Funktion `par` lassen sich sehr viele Einstellung der Grafik verändern. Viele Einstellungen übergibt die Funktion `plot` selbständig an `par`, zu.B. `log` (Logarithmieren der Achsen), `cex` (Größe eines Punkts) oder `col` (Farbe). Andere können aber nur durch Aufrufen der Funktion `par` verändert werden. Dazu gehören die inneren Ränder `mar` und die äußeren Ränder `oma`, die Aufteilung der Grafikebene mit `mfrow` oder `mfcol`.


```{block, type='rmdalert'}
Richtige Benutzung von `par`:

- Parameter setzen: `op <- par( ... )`
- plotten
- Parameter auf Standard zurück setzen: `par(op)`
```

Die Zuweisung `op <- par( ... )` speichert die Standardeinstellungen im Objekt `par`, bevor Sie sie ändern. Der Aufruf `par(op)` setzt Ihre Änderungen zurück. Das ist sehr praktisch, wenn Sie z.B. die Aufteilung der Grafikebene nicht mehr benötigen. Wenn Sie die Parameter nicht zurücksetzen, bleiben diese bestehen, bis das Grafikfenster geschlossen wird (z.B. mit `dev.off()`).

Um die Ränder zu verändern, rufen wir `par` auf und beschneiden die Ränder, damit Sie den Unterschied erkennen können.

```{r}
op <- par(mar = c(1, 1, 1, 1))
plot(my_date, meteo$MO_TT, type = 'b', xlab = 'Zeit', ylab = 'Temperatur [°C]', main = 'Klimadaten der DWD-Station Köln-Bonn', ylim = c(0, 30))

# Minimumtemperatur in rot
lines(my_date, meteo$MO_TN, col = 'blue')

# Maximumtemperatur in blau
lines(my_date, meteo$MO_TX, col = 'red')
```

Die Achsenbeschriftungen und die Zahlen haben jetzt nicht mehr genug Platz und verschwinden. Die Größe der Ränder wird in Zeilen angegeben, ist also relativ zur Gesamtgröße. Die Standardeinstellung ist `c(5, 4, 4, 2) + 0.1`.

Einige häufig genutzte Argumente in Grafikfunktionen und in `par` [nach @Ligges2008, verändert]. Schlagen Sie die Erklärungen dazu immer in `?par` oder `?plot` nach.

Funktion | Beschreibung|
:-------- | :------------ |
`axes` | Achsen sollen (nicht) eingezeichnet werden|
`bg` |Hintergrundfarbe|
`cex` |Größe eines Punktes bzw. Buchstaben|
`col` |Farben|
`las` |Ausrichtung der Achsenbeschriftung|
`log` |Logarithmierte Darstellung|
`lty`, `lwd` |Linientyp (gestrichelt, ...) und Linienbreite|
`main` |Überschrift |
`mar` |Größe der inneren Ränder für Achsenbeschriftung etc.|
`mfcol`, `mfrow` |mehrere Grafiken in einem Bild|
`pch` |Symbol für einen Punkt|
`type` |Typ (l für Linie, p für Punkt, b für beides, n für nichts)|
`usr` |Ausmaße der Achsen auslesen|
`xlab`, `ylab` |x-/y-Achsenbeschriftung|
`xlim`, `ylim` |zu plottender Bereich in x-/y- Richtung|
`xpd` |in die Ränder hinein zeichnen|

## Inhalt der live Einführung
- `plot`, `barplot`, `mfrow`
- Aufgaben \@ref(wahlbeteiligung), \@ref(zweitstimme) und \@ref(zweigrafiken).
- Speichern als pdf
