# Tidyverse {#tidyverse}

```{block, type = 'rmdoutcomes'}
- Kernpakete aus `tidyverse` benennen
- ein einfaches Workflow (Daten einlesen, zusammenfassen, darstellen) mit `tidyverse` durchführen
- Funktionen des Pakets `dplyr` für Datentransformation anwenden
```

`tidyverse` ist eine Sammlung von R-Pakete, die explizit für Datenanalyse entwickelt wurden (https://www.tidyverse.org/). `tidyverse` versucht durch gemeinsame Philosophie in Design, Grammatik und Datenstruktur die Datenanalyse zu erleichtern (https://design.tidyverse.org/). Auch wenn `tidyverse` auf den ersten Blick etwas fremd erscheint, es ist ein Teil von R, kein eigenes Universum. Es ist also völlig in Ordnung, R-Basisfunktionen mit Funktionen aus `tidyverse` zu mischen.

Das wichtigste Einführungsbuch zu `tidyverse` ist sicherlich **R4DS**: "R for Data Science" [@Wickham2017], das Sie kostenlos online lesen können (https://r4ds.had.co.nz/).

## Grundpakete

`tidyverse` enthält folgende Grundpakete, die alle installiert werden, wenn Sie `install.packages('tidyverse')` eingeben.

Paketname | Kurzbeschreibung|
:-------- | :------------ |
`ggplot2`| Visualisierung |
`dplyr`| Datentransformation |
`tidyr`| Datenbereinigung |
`readr`| Daten einlesen  |
`purrr`| Funktionale Programmierung (Funktionen auf Objekte anwenden) |
`tibble`| Erweiterung von `data.frame` |
`stringr`| Funktionen für Strings, d.h. Textvariablen |
`forcats`| Funktionen für `factor` |

Jedes dieser Pakete hat ein Cheat Sheet, eine übersichtliche Zusammenstellung der Funktionen des Pakets. Sie bekommen die Cheet Sheats über die `tidyverse`-Seite (https://www.tidyverse.org/packages/), indem Sie auf das jeweilige Paket klicken und zum Abschnitt 'Cheatsheet' scrollen.

## Der Workflow

### Daten einlesen

Sie kennen bereits die sehr umfangreiche Funktion `read.table()` zum Einlesen der Daten. Die Funktion `read_delim()` ist die allgemeinste Funktion der `read_*` Familie aus `readr` in `tidyverse`; `read_csv()` und `read_csv2()` sind jeweils für komma- und strichpunkt-getrennte Datensätze gedacht. Man könnte berechtigterweise fragen, warum eine neue Funktion für etwas erfinden, was es schon gibt. Die Autoren von `tidyverse` versprechen Konsistenz und Geschwindigkeit. Ersteres war schon immer ein Problem von R, da es nicht von Computerspezialisten, sondern von Anwendern erfunden wurde. Daher ist eine Vereinheitlichung durch `tidyverse` mehr als willkommen. Und Geschwindigkeit ist spätestens bei größeren Datensätzen ein wichtiger Punkt.

Wir sehen uns erneut Daten des Deutschen Wetterdienstes an, wie im Kapitel \@ref(visualisieren). Nur diesmal sind es Stundenwerte für relative Luftfeuchte (%) und Lufttemperatur (°C). Die Daten von drei Wetterstationen, nämlich Hof, Frankfurt und Köln-Bonn, befinden sich in der Datei `r file.name("Drei_Stationen.csv")` Beim Einlesen zeigt Ihnen `read_delim()` bereits, welche Spalten und welche Datentypen es erkennt, mit `trim_ws = T` werden Leerzeichen aus Spalten entfernt.

```{r}
library(tidyverse)

temp_humid <- read_delim('Drei_Stationen.csv', delim = ';',
                         trim_ws = T)
```
Eine weitere Kontrolle bietet die Funktion `print()`, die das eingelesene Ergebnis übersichtlich (und im Notebook interaktiv) darstellt. Sie müssen hier nicht mehr `head()` verwenden, da grundsätzlich nur die ersten 10 Zeilen dargestellt werden.

```{r}
print(temp_humid)
```

Das gleiche Ergebnis bekommen Sie auch ohne `print()`, wenn Sie wie gewohnt den Namen des Objekts tippen.

```{r}
temp_humid
```


In diesem Datensatz sind folgende Parameter (Spalten) enthalten (s. Datensatzbeschreibung des DWDs)

Parameter | Beschreibung |
:--------|:---------------|
STATIONS_ID | Stationsidentifikationsnummer |
MESS_DATUM | Zeitstempel im Format yyyymmddhh |
QN_9 | Qualitätsniveau der nachfolgenden Spalten |
TT_TU | Lufttemperatur in 2m Höhe °C |
RF_TU | relative Feuchte % |
eor | Ende data record


```{r}
class(temp_humid)
```

Das Objekt `temp_humid` ist ein sogen. Tibble, ein `data.frame` mit "modernem" Verhalten. Z.B. gibt die Funktion `print()` nur die ersten 10 Zeilen aus, die Datentypen in den Spalten werden in hellgrau zwischen '<>' mit angegeben etc. Mehr zu Tibbles finden Sie in Kapitel 10 "Tibbles" in R4DS.

Ein weiteres Paket, dass zwar nicht zum Kern von `tidyverse` gehört, jedoch trotzdem extrem nützlich ist, heißt `lubridate`. Es hilft, Text in richtige Datums-Objekte zu transformieren (ohne sich die kryptischen Datumsformate von R merken zu müssen). Wir transformieren die Spalte `temp_humid$MESS_DATUM` in ein richtiges Datum mit Uhrzeit.

```{r}
library(lubridate)

temp_humid$MESS_DATUM <- ymd_h(temp_humid$MESS_DATUM)

print(temp_humid)
```

### Daten zusammenfassen

Die drei Wetterstationen haben folgende IDs:

```{r}
station_ids <-  tibble('Hof' = '2261', 'Frankfurt' = '1420', 'Koeln' = '2667')
```


Ich möchte wissen, wie viele Messpunkte es pro Station gibt:


```{r}
temp_humid %>% 
  count()
```

Die Zeichenkombination `%>%` heißt Pipe-Operator (*pipe*) und wird als 'und dann' gelesen (*then*). Der Ausdruck `temp_humid %>% count()` heißt also: nimm `temp_humid` und dann zähle die Einträge. Der Pipe-Operator ist die Kernphilosophie von `tidyverse` und wird Ihnen überall begegnen. Der Operator stammt aus dem Paket `magrittr` (https://magrittr.tidyverse.org/). Seine Hauptaufgabe ist es, den Code übersichtlicher und besser lesbar zu machen (vielleicht nicht gleich zu Beginn der Lernkurve aber schon sehr bald `r emo::ji('smile')`).

Die Funktion `count()` gehört zum Paket `dplyr`, das für Datentransformationen zuständig ist. Dieses Paket enthält 5 Grundfunktionen (alle nach Verben benannt `r emo::ji('smile')`):

Funktion | Bedeutung |
:-----------|:-----------|
`filter()` | Wähle Daten anhand ihrere Werte |
`arrange()` | Sortiere Zeilen |
`select()` | Wähle Variablen anhand ihrere Namen |
`mutate()` | Erstelle neue Variablen als Funktionen vorhandener Variablen |
`summarize()` | Fasse Daten zusammen |

Ich möchte nun wissen, wie viele Messpunkte es für Köln-Bonn gibt. `tidyverse` ist konsistent: jeder Aufruf einer Funktion aus `dplyr` gibt ein `tiblle` zurück (und nicht mal `data.frame` mal Vektor).

```{r}
temp_humid %>% 
  filter(STATIONS_ID == station_ids$Koeln) %>%
  count()
```

### Daten plotten

Wir wählen nur die Station Köln-Bonn und plotten die Stundenwerte der Temperatur mit dem Paket `ggplot2`.

```{r}
# Köln-Bonn wählen
koeln <- temp_humid %>% 
  filter(STATIONS_ID == station_ids$Koeln)

koeln
```

```{r}
# Plotten
ggplot(data = koeln, aes(x = MESS_DATUM, y = TT_TU)) + 
  geom_line()
```

Sie werden sehr bald schon das Paket `ggplot2` nicht mehr missen wollen. Es erstellt mit wenig Aufwand sehr ansehnliche Grafiken. Natürlich müssen Sie, wie in Base-R auch, für professionelle Grafiken nacharbeiten.

`ggplot2` folgt einer sogen. Grafikgrammatik (*grammer of graphics*), indem es seine Grafiken mit '+' aufbaut. Erst sagt man in der Funktion `ggplot()` welchen Datensatz man plotten möchte, was auf die x- und y-Achse kommt und ob man z.B. Farbe für Gruppen in Daten möchte. All diese sichtbaren Elemente nennt man Ästhetiken (Parameter `aes`). Erst wenn diese 'Formalien' geklärt sind, sagt man, welche Form der Darstellung man möchte. Im oberen Beispiel ist es ein Linienplot. Alle Darstellungsarten in `ggplot2` beginnen mit `geom_*()` und sind daher konsistent benannt. Die Informationen zu Daten, x-, y-Achse etc. werden an die `geom_*()`-Funktionen von der Mutterfunktion `ggplot()` weiter vererbt. Daher sind die Klammern in `geom_line()` leer.

Wir wollen nun die Monatsmittelwerte für die Temperatur berechnen und diese darstellen. Als erstes erstellen wir zwei neue Spalten, die jeweils das Jahr und den Monat beinhalten. Die beiden neuen Spalten werden am Ende von  `temp_humid` angehängt.

```{r}
temp_humid <- mutate(temp_humid, 
                     year = year(temp_humid$MESS_DATUM),
                     month = month(temp_humid$MESS_DATUM))

temp_humid
```

Jetzt können wir einen neuen Datensatz mit den Mittelwerten erstellen. Dafür gruppieren wir erst einmal die Daten nach `STATIONS_ID`, `year` und `month`. Die Mittelwerte sollen ja je Station, Jahr und Monat berechnet werden.

```{r}
by_month <- group_by(temp_humid, STATIONS_ID, year, month)
monthly_means <- summarize(by_month, mean_T = mean(TT_TU), mean_RH = mean(RF_TU))

monthly_means
```

Die Struktur von `monthly_means` zeigt uns, dass es sich um gruppierte Daten handelt.

```{r}
str(monthly_means)
```

Da wir aber mit den Daten weiter rechnen wollen, ist es besser, die Gruppierung wieder aufzugeben. Es könnte sonst später Fehlermeldungen geben.

```{r}
monthly_means <- ungroup(monthly_means)
```


Um die Daten als Zeitreihen zu plotten, erstellen wir noch eine ordentliche Zeit-Spalte. Die Funktion `parse_date_time()` kann aus Character richtige Datums-Zeitobjekte erstellen. Sie ist allgemeienr als die oben verwendete `ymd()` Funktion, da man hier das Format explizit angeben kann. In unserem Fall ist das Format 'ym' für Jahr und Monat.

```{r}
monthly_means <- monthly_means %>%
  mutate(my_date = parse_date_time(paste0(monthly_means$year,
                  monthly_means$month), 'ym', tz = 'CET'))
```


```{r}
ggplot(data = monthly_means, aes(x = my_date, y = mean_T, 
            col = factor(STATIONS_ID))) + 
  geom_line() + 
  labs(x = 'Time', y = 'Temperature (°C)', color = 'Station')
```

Wir werden in eine spätere Kapitel auf `ggplot2` genauer eingehen. Fürs Erste soll es als Appetithappen reichen `r emo::ji('cake')`.

## Weiterführende Literatur und Videos

- R4DS: Kapitel 5 "Data transformation", 11 "Data import"

- Eine live Analyse des Hauptautors von `tidyverse`, Hadley Wickham. Empfehlenswert, auch wenn er viel zu schnell tippt `r emo::ji('smile')`.

<iframe width="913" height="432" src="https://www.youtube.com/embed/go5Au01Jrvs" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>

## Inhalt der live Einführung

Verschiedene Funktionen aus `tydiverse` anhand der Aufgaben \@ref(fledermaus3) und \@ref(klausur)
