[
["tidyverse.html", "Kapitel 8 Tidyverse 8.1 Grundpakete 8.2 Der Workflow 8.3 WeiterfÃ¼hrende Literatur und Videos 8.4 Inhalt der live EinfÃ¼hrung", " Kapitel 8 Tidyverse Kernpakete aus tidyverse benennen ein einfaches Workflow (Daten einlese, zusammenfassen, darstellen) mit tidyverse durchfÃ¼hren FUnktionen des Pakets dplyr fÃ¼r Datentransformation anwenden tidyverse ist eine Sammlunt von R-Pakete, die explizit fÃ¼r Datenanalyse entwickelt wurden (https://www.tidyverse.org/). tidyverse versucht durch gemeinsame Philosophie in Desing, Grammatik und Datenstruktur die Datenanalyse zu erleichtern. Auch wenn tidyverse auf den ersten Blick etwas fremd erscheint, es ist ein Teil von R, kein eigenes Universum. Es ist also vÃ¶llig in Ordnung, R-Basisfunktionen mit Funtionen aus tidyverse zu mischen. Das wichtigste EinfÃ¼hrungsbuch zu tidyverse ist sicherlicht R4DS: â€œR for Data Scienceâ€ (Wickham and Grolemund 2017), das Sie kostenlos online lesen kÃ¶nnen (https://r4ds.had.co.nz/). 8.1 Grundpakete tidyverse enthÃ¤lt folgende Grundpakete, die alle installiert werden, wenn Sie install.packages('tidyverse') eingeben. Paketname Kurzbeschreibung ggplot2 Visualisierung dplyr Datentransformation tidyr Datenbereinigung readr Daten einlesen purrr Funktionale Programmierung (Funktionen auf Objekte anwenden) tibble Erweiterung von data.frame stringr Funktionen fÃ¼r Strings, d.h. Textvariablen forcats Funktionen fÃ¼r factor Jedes dieser Pakete hat ein Cheat Sheet, eine Ã¼bersichtliche Zusammenstellung der Funktionen des Pakets. Sie bekommen die Cheet Sheats Ã¼ber die tidyverse-Seite (https://www.tidyverse.org/packages/), indem Sie auf das jeweilige Paket klicken und zum Abschnitt â€˜Cheatsheetâ€™ scrollen. 8.2 Der Workflow 8.2.1 Daten einlesen Sie kennen bereits die sehr umfangreiche Funktion read.table() zum Einlesen der Daten. Die Funktion read_delim() ist die allgemeinste Funktion der read_* Familie aus readr in tidyverse; read_csv() und read_csv2() sind jeweils fÃ¼r komma- und strichpunkt-getrennte DatensÃ¤tze gedacht. Man kÃ¶nnte berechtigterweise fragen, warum eine neue Funktion fÃ¼r etwas erfinden, was es schon gibt. Die Autoren von tidyverse versprechen Konsistenz und Geschwindigkeit. Ersteres war schon immer ein Problem von R, da es nicht von Computerspezialisten, sondern von Anwendern erfunden wurde. Daher ist eine Vereinheitlichung durch tidyverse mehr als willkommen. Und Geschwindigkeit ist spÃ¤testens bei grÃ¶ÃŸeren DatensÃ¤tzen ein wichtiger Punkt. Wir sehen uns erneut Daten des Deutschen Wetterdienstes an, wie im Kapitel 5. Nur diesmal sind es Stundenwerte fÃ¼r relative Luftfeuchte (%) und Lufttemperatur (Â°C). Die Daten von drei Wetterstationen, nÃ¤mlich Hof, Frankfurt und KÃ¶ln-Bonn, befinden sich in der Datei Drei_Stationen.csv Beim Einlesen zeigt Ihnen read_delim() bereits, welche Spalten und Welche Datentypen es erkennt, mit trim_ws = T werden Leerzeichen aus Spalten entfernt. library(tidyverse) ## â”€â”€ Attaching packages â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ tidyverse 1.3.0 â”€â”€ ## âœ“ ggplot2 3.2.1 âœ“ purrr 0.3.3 ## âœ“ tibble 2.1.3 âœ“ dplyr 0.8.3 ## âœ“ tidyr 1.0.2 âœ“ stringr 1.4.0 ## âœ“ readr 1.3.1 âœ“ forcats 0.4.0 ## â”€â”€ Conflicts â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ tidyverse_conflicts() â”€â”€ ## x dplyr::filter() masks stats::filter() ## x dplyr::lag() masks stats::lag() temp_humid &lt;- read_delim(&#39;Drei_Stationen.csv&#39;, delim = &#39;;&#39;, trim_ws = T) ## Parsed with column specification: ## cols( ## STATIONS_ID = col_double(), ## MESS_DATUM = col_double(), ## QN_9 = col_double(), ## TT_TU = col_double(), ## RF_TU = col_double(), ## eor = col_character() ## ) Eine weitere Kontrolle bietet die Funktion print(), die das eingelesene Ergebnis Ã¼bersichtlich (und im Notebook interaktiv) darstellt. SIe mÃ¼ssen hier nicht mehr head() verwenden, da grundsÃ¤tzlich nur die ersten 10 Zeilen dargestellt werden. print(temp_humid) ## # A tibble: 39,600 x 6 ## STATIONS_ID MESS_DATUM QN_9 TT_TU RF_TU eor ## &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; ## 1 2261 2018111900 3 -2.8 99 eor ## 2 2261 2018111901 3 -2.5 100 eor ## 3 2261 2018111902 3 -2.3 100 eor ## 4 2261 2018111903 3 -2 100 eor ## 5 2261 2018111904 3 -1.9 99 eor ## 6 2261 2018111905 3 -2.1 99 eor ## 7 2261 2018111906 3 -1.8 99 eor ## 8 2261 2018111907 3 -1.5 99 eor ## 9 2261 2018111908 3 -1.1 99 eor ## 10 2261 2018111909 3 -0.6 97 eor ## # â€¦ with 39,590 more rows In diesem Datensatz sind folgende Parameter (Spalten) enthalten (s. Datensatzbeschreibung des DWDs) Parameter Beschreibung STATIONS_ID Stationsidentifikationsnummer MESS_DATUM Zeitstempel im Format yyyymmddhh QN_9 QualitÃ¤tsniveau der nachfolgenden Spalten TT_TU Lufttemperatur in 2m HÃ¶he Â°C RF_TU relative Feuchte % eor Ende data record class(temp_humid) ## [1] &quot;spec_tbl_df&quot; &quot;tbl_df&quot; &quot;tbl&quot; &quot;data.frame&quot; Das Objekt temp_humid ist ein sogen. Tibble, ein data.frame mit â€œmodernemâ€ Verhalten. Z.B. gibt die Funktion print() nur die ersten 10 Zeilen aus, die Datentypen in den Spalten werden in hellgrau zwischen â€˜&lt;&gt;â€™ mit angegeben etc. Mehr zu Tibbles finden Sie in Kapitel 10 â€œTibblesâ€ in R4DS. Ein weiteres Paket, dass zwar nicht zum Kern von tidyverse gehÃ¶rt, jedoch trotzdem extrem nÃ¼tzlich ist, heiÃŸt lubridate. Es hilft, Text in richtige Datums-Objekte zu transformieren (ohne sich die kryptischen Datumsformate von R merken zu mÃ¼ssen). Wir transformieren die Spalte temp_humid$MESS_DATUM in ein richtiges Datum mit Uhrzeit. library(lubridate) ## ## Attaching package: &#39;lubridate&#39; ## The following objects are masked from &#39;package:dplyr&#39;: ## ## intersect, setdiff, union ## The following objects are masked from &#39;package:base&#39;: ## ## date, intersect, setdiff, union temp_humid$MESS_DATUM &lt;- ymd_h(temp_humid$MESS_DATUM) print(temp_humid) ## # A tibble: 39,600 x 6 ## STATIONS_ID MESS_DATUM QN_9 TT_TU RF_TU eor ## &lt;dbl&gt; &lt;dttm&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; ## 1 2261 2018-11-19 00:00:00 3 -2.8 99 eor ## 2 2261 2018-11-19 01:00:00 3 -2.5 100 eor ## 3 2261 2018-11-19 02:00:00 3 -2.3 100 eor ## 4 2261 2018-11-19 03:00:00 3 -2 100 eor ## 5 2261 2018-11-19 04:00:00 3 -1.9 99 eor ## 6 2261 2018-11-19 05:00:00 3 -2.1 99 eor ## 7 2261 2018-11-19 06:00:00 3 -1.8 99 eor ## 8 2261 2018-11-19 07:00:00 3 -1.5 99 eor ## 9 2261 2018-11-19 08:00:00 3 -1.1 99 eor ## 10 2261 2018-11-19 09:00:00 3 -0.6 97 eor ## # â€¦ with 39,590 more rows 8.2.2 Daten zusammenfassen Die drei Wetterstationen haben folgende IDs: station_ids &lt;- tibble(&#39;Hof&#39; = &#39;2261&#39;, &#39;Frankfurt&#39; = &#39;1420&#39;, &#39;Koeln&#39; = &#39;2667&#39;) Ich mÃ¶chte wissen, wie viele Messpunkte es pro Station gibt: temp_humid %&gt;% count() ## # A tibble: 1 x 1 ## n ## &lt;int&gt; ## 1 39600 Die Zeichenkombination %&gt;% heiÃŸt Pipe-Operator (pipe) und wird als â€˜und dannâ€™ gelesen (then). Der Ausdruck temp_humid %&gt;% count() heiÃŸt also: nimm temp_humid und dann zÃ¤hle die EintrÃ¤ge. Der Pipe-Operator ist die Kernphilosophie von tidyverse und wird Ihnen Ã¼berall begegnen. Der Operator stammt aus dem Paket magrittr (https://magrittr.tidyverse.org/). Seine Hauptaufgabe ist es, den Code Ã¼bersichtlicher und besser lesbar zu machen (vielleicht nicht gleich zu Beginn der Lernkurve aber schon sehr bald ğŸ˜„). Die Funktion count() gehÃ¶rt zum Paket dplyr, das fÃ¼r Datentransformationen zustÃ¤ndig ist. Dieses Paket enthÃ¤lt 5 Grundfunktionen (alle nach Verben benannt ğŸ˜„): Funktion Bedeutung filter() WÃ¤hle Daten anhand ihrere Werte arrange() Sortiere Zeilen select() WÃ¤hle Variablen anhand ihrere Namen mutate() Erstelle neue Variablen als Funktionen vorhandener Variablen summarize() Fasse Daten zusammen Ich mÃ¶chte nun wissen, wie viele Messpunkte es fÃ¼r KÃ¶ln-Bonn gibt. tidyverse ist konsistent: jeder Aufruf einer Funktion aus dplyr gibt ein tiblle zurÃ¼ck (und nicht mal data.frame mal Vektor). temp_humid %&gt;% filter(STATIONS_ID == station_ids$Koeln) %&gt;% count() ## # A tibble: 1 x 1 ## n ## &lt;int&gt; ## 1 13200 8.2.3 Daten plotten Wir wÃ¤hlen nur die Station KÃ¶ln-Bonn und plotten die Stundenwerte der Temperatur mit dem Paket ggplot2. # KÃ¶ln-Bonn wÃ¤hlen koeln &lt;- temp_humid %&gt;% filter(STATIONS_ID == station_ids$Koeln) koeln ## # A tibble: 13,200 x 6 ## STATIONS_ID MESS_DATUM QN_9 TT_TU RF_TU eor ## &lt;dbl&gt; &lt;dttm&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; ## 1 2667 2018-11-19 00:00:00 3 -2.9 69 eor ## 2 2667 2018-11-19 01:00:00 3 -1.7 78 eor ## 3 2667 2018-11-19 02:00:00 3 -2.4 82 eor ## 4 2667 2018-11-19 03:00:00 3 0.2 89 eor ## 5 2667 2018-11-19 04:00:00 3 1.7 84 eor ## 6 2667 2018-11-19 05:00:00 3 0.3 90 eor ## 7 2667 2018-11-19 06:00:00 3 3.4 84 eor ## 8 2667 2018-11-19 07:00:00 3 4.1 81 eor ## 9 2667 2018-11-19 08:00:00 3 3.9 80 eor ## 10 2667 2018-11-19 09:00:00 3 4.8 78 eor ## # â€¦ with 13,190 more rows # Plotten ggplot(data = koeln, aes(x = MESS_DATUM, y = TT_TU)) + geom_line() Sie werden sehr bald schon das Paket ggplot2 nicht mehr missen wollen. Es erstellt mit wenigem Aufwand sehr ansehnliche Grafiken. NatÃ¼rlich mÃ¼ssen Sie, wie in Base-R auch, fÃ¼r professionelle Grafiken nacharbeiten. ggplot2 folgt einer sogen. Grafikgrammatik (grammer of graphics), indem es seine Grafiken mit â€˜+â€™ aufbaut. Erst sagt man in der Funktion ggplot() welchen Datensatz man plotten mÃ¶chte, was auf die x- und y-Achse kommt und ob man z.B. Farbe fÃ¼r Gruppen in Daten mÃ¶chte. All diese sichtbaren Elemente nennt man Ã„sthtiken (Parameter aes). Erst wenn diese â€˜Formalienâ€™ geklÃ¤rt sind, sagt man, welche Form der Darstellung man mÃ¶chte. Im oberen Beispiel ist es ein Linienplot. Alle Darstellungsarten in ggplot2 beginnen mit geom_*() und sind daher konsistent benannt. Die Informationen zu Daten, x-, y-Achse etc. werden an die geom_*()-Funktionen von der Mutterfunktion ggplot() weiter vererbt. Daher sind die Klammern in geom_line() leer. Wir wollen nun die Monatsmittelwerte fÃ¼r die Temperatur berechnen und diese darstellen. Als erstes erstellen wir zwei neue Spalten, die jeweils das Jahr und den Monat beinhalten. Die beiden neuen Spalten werden am Ende von temp_humid angehÃ¤ngt. temp_humid &lt;- mutate(temp_humid, year = year(temp_humid$MESS_DATUM), month = month(temp_humid$MESS_DATUM)) temp_humid ## # A tibble: 39,600 x 8 ## STATIONS_ID MESS_DATUM QN_9 TT_TU RF_TU eor year month ## &lt;dbl&gt; &lt;dttm&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 2261 2018-11-19 00:00:00 3 -2.8 99 eor 2018 11 ## 2 2261 2018-11-19 01:00:00 3 -2.5 100 eor 2018 11 ## 3 2261 2018-11-19 02:00:00 3 -2.3 100 eor 2018 11 ## 4 2261 2018-11-19 03:00:00 3 -2 100 eor 2018 11 ## 5 2261 2018-11-19 04:00:00 3 -1.9 99 eor 2018 11 ## 6 2261 2018-11-19 05:00:00 3 -2.1 99 eor 2018 11 ## 7 2261 2018-11-19 06:00:00 3 -1.8 99 eor 2018 11 ## 8 2261 2018-11-19 07:00:00 3 -1.5 99 eor 2018 11 ## 9 2261 2018-11-19 08:00:00 3 -1.1 99 eor 2018 11 ## 10 2261 2018-11-19 09:00:00 3 -0.6 97 eor 2018 11 ## # â€¦ with 39,590 more rows Jetzt kÃ¶nnen wir einen neuen Datensatz mit den Mittelwerten erstellen. DafÃ¼r gruppieren wir erst einmal die Daten nach STATIONS_ID, year und month. Die Mittelwerte sollen ja je Station, Jahr und Monat berechnet werden. by_month &lt;- group_by(temp_humid, STATIONS_ID, year, month) monthly_means &lt;- summarize(by_month, mean_T = mean(TT_TU), mean_RH = mean(RF_TU)) monthly_means ## # A tibble: 57 x 5 ## # Groups: STATIONS_ID, year [9] ## STATIONS_ID year month mean_T mean_RH ## &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 1420 2018 11 4.00 79.7 ## 2 1420 2018 12 4.73 83.7 ## 3 1420 2019 1 2.12 79.3 ## 4 1420 2019 2 4.48 74.1 ## 5 1420 2019 3 8.28 68.5 ## 6 1420 2019 4 11.7 61.0 ## 7 1420 2019 5 12.7 67.5 ## 8 1420 2019 6 21.4 60.6 ## 9 1420 2019 7 21.6 55.6 ## 10 1420 2019 8 20.7 65.6 ## # â€¦ with 47 more rows Die Struktur von monthly_means zeigt uns, dass es sich um gruppierte Daten handelt. str(monthly_means) ## Classes &#39;grouped_df&#39;, &#39;tbl_df&#39;, &#39;tbl&#39; and &#39;data.frame&#39;: 57 obs. of 5 variables: ## $ STATIONS_ID: num 1420 1420 1420 1420 1420 1420 1420 1420 1420 1420 ... ## $ year : num 2018 2018 2019 2019 2019 ... ## $ month : num 11 12 1 2 3 4 5 6 7 8 ... ## $ mean_T : num 4 4.73 2.12 4.48 8.28 ... ## $ mean_RH : num 79.7 83.7 79.3 74.1 68.5 ... ## - attr(*, &quot;groups&quot;)=Classes &#39;tbl_df&#39;, &#39;tbl&#39; and &#39;data.frame&#39;: 9 obs. of 3 variables: ## ..$ STATIONS_ID: num 1420 1420 1420 2261 2261 ... ## ..$ year : num 2018 2019 2020 2018 2019 ... ## ..$ .rows :List of 9 ## .. ..$ : int 1 2 ## .. ..$ : int 3 4 5 6 7 8 9 10 11 12 ... ## .. ..$ : int 15 16 17 18 19 ## .. ..$ : int 20 21 ## .. ..$ : int 22 23 24 25 26 27 28 29 30 31 ... ## .. ..$ : int 34 35 36 37 38 ## .. ..$ : int 39 40 ## .. ..$ : int 41 42 43 44 45 46 47 48 49 50 ... ## .. ..$ : int 53 54 55 56 57 ## ..- attr(*, &quot;.drop&quot;)= logi TRUE Da wir aber mit den Daten weiter rechnen wollen, ist es besser, die Gruppierung wieder aufzugehben, da es sonst Fehlermeldungen geben kÃ¶nnte. monthly_means &lt;- ungroup(monthly_means) Um die Daten als Zeitreihen zu plotten, erstellen wir noch eine ordentliche Zeit-Spalte. monthly_means &lt;- monthly_means %&gt;% mutate(my_date = parse_date_time(paste0(monthly_means$year, monthly_means$month), &#39;ym&#39;, tz = &#39;CET&#39;)) ggplot(data = monthly_means, aes(x = my_date, y = mean_T, col = factor(STATIONS_ID))) + geom_line() + labs(x = &#39;Time&#39;, y = &#39;Temperature (Â°C)&#39;, color = &#39;Station&#39;) 8.3 WeiterfÃ¼hrende Literatur und Videos R4DS: Kapitel 5 â€œData transformationâ€, 11 â€œData importâ€ Eine live Analyse des Hauptautors von tidyverse, Hadley Wickham. Empfehlenswert, auch wenn er viel zu schnell tippt ğŸ˜„. 8.4 Inhalt der live EinfÃ¼hrung "]
]
