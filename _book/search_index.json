[
["funktionen.html", "Kapitel 7 Funktionen 7.1 Eigene Funktionen schreiben 7.2 Fallunterscheidungen 7.3 for-Schleifen (for loops) 7.4 Weiterf√ºhrende Literatur 7.5 Inhalt der live Einf√ºhrung", " Kapitel 7 Funktionen Den Aufbau von Funktionen in R beschreiben Den Aufruf von Funktionen in R erkl√§ren Einfache Funktionen selbst schreiben Fallunterscheidungen Schleifen Was genau Funktionen sind und wie man sie in R aufruft, lesen Sie bitte bei Ligges (2008) in Kapitel 4.1 nach. In diesem Kapitel des Skripts geht es um das Schreiben der eigenen Funktionen, Fallunterscheidungen mit if-else und for Schleifen. 7.1 Eigene Funktionen schreiben Funktionen sind eine gro√üartige M√∂glichkeit, sich das Leben einfacher zu machen. Sie k√∂nnen repetitive Aufgaben erledigen, ohne dass wir st√§ndig mit Copy und Paste hantieren m√ºssen, machen unsere Notebooks √ºbersichtlich und helfen, Fehler und Inkonsistenzen zu vermeiden. Als Faustregel gilt: wenn Sie ein St√ºck Code mehr als 2 Mal kopieren und ab√§ndern, wird es Zeit f√ºr eine Funktion üòÑ. Schauen wir uns ein Beispiel an. Als erstes w√ºrfeln wir ein paar Daten aus der Gleichverteilung mit unterschiedlichen Minima und Maxima und sehen uns die Zusammenfassung und die Standardabweichungen an. my_data &lt;- data.frame(col1 = runif(20, min = 3, max = 10), col2 = runif(20, min = 7, max = 12), col3 = runif(20, min = 13, max = 100)) summary(my_data) ## col1 col2 col3 ## Min. :3.040 Min. : 7.064 Min. :16.51 ## 1st Qu.:4.014 1st Qu.: 8.542 1st Qu.:27.26 ## Median :6.749 Median : 9.995 Median :64.46 ## Mean :6.385 Mean : 9.807 Mean :58.03 ## 3rd Qu.:8.112 3rd Qu.:11.079 3rd Qu.:82.35 ## Max. :9.451 Max. :11.704 Max. :98.03 sapply(my_data, sd) ## col1 col2 col3 ## 2.093886 1.642531 29.697085 Ich m√∂chte die Daten so transformieren, dass alle Variablen im Datensatz (d.h. Spalten) einen Mittelwert von 0 und eine Standardabweichung von 1 haben. Dazu ziehe ich den Mittelwert ab und teile durch die Standardabweichung. Das ist eine klassische Transformation (manchmal \\(z\\)-Transformation genannt), die manche Analysemethoden (z.B. Hauptkomponentenanalyse) als Vorbehandlung der Daten verlangen. Erst einmal das Naheliegende: Transformation per Copy und Paste. my_data_trans &lt;- data.frame(col1_trans = (my_data$col1 - mean(my_data$col1))/sd(my_data$col1), col2_trans = (my_data$col2 - mean(my_data$col2))/sd(my_data$col1), col3_trans = (my_data$col3 - mean(my_data$col3))/sd(my_data$col3)) Haben Sie den Fehler bemerkt? Ich habe einmal vergessen eine 1 durch eine 2 zu ersetzten. Das merke ich aber nur, wenn ich mir das Ergebnis ansehen. Die Standardabweichung in col2_trans ist nicht gleich 1. summary(my_data_trans) ## col1_trans col2_trans col3_trans ## Min. :-1.5978 Min. :-1.30965 Min. :-1.3982 ## 1st Qu.:-1.1326 1st Qu.:-0.60400 1st Qu.:-1.0361 ## Median : 0.1736 Median : 0.09008 Median : 0.2165 ## Mean : 0.0000 Mean : 0.00000 Mean : 0.0000 ## 3rd Qu.: 0.8247 3rd Qu.: 0.60783 3rd Qu.: 0.8191 ## Max. : 1.4644 Max. : 0.90597 Max. : 1.3470 sapply(my_data_trans, sd) ## col1_trans col2_trans col3_trans ## 1.0000000 0.7844411 1.0000000 So etwas passiert sehr schnell und wird durch das Schreiben einer Funktion vermieden. Jede Funktionsdefinition beginnt mit der Wahl des Namens. Es ist eine gute Idee, sich einen konsistenten und sauberen Stil gleich am Anfang anzugew√∂hnen. Seien Sie nett zu Ihrem zuk√ºnftigen Ich und anderen Menschen, die Ihren Code lesen werden üòÑ. Es ist ein guter Stil, Verben als Funktionsnamen zu nutzen, die beschreiben, was eine Funktion macht. In jedem Fall, w√§hlen Sie keine Namen, die schon f√ºr Funktionen oder Variablen vergeben sind! Das w√ºrde die urspr√ºnglichen Funktionen oder Variablen einfach √ºberschreiben. Wir nennen unsere Funktion z_transform, weil sie Daten \\(z\\)-transformiert. Bei zusammengesetzten Namen sollten Sie den Unterstrich verwenden. Das macht den Namen einfacher zu lesen. z_transofrm &lt;- function(x) { (x - mean(x))/sd(x) } Bei jeder Funktionsdefinition arbeiten Sie drei Schritte ab: Namen finden und das Skelett aus Name_der_Funktion &lt;- function() {} hin schreiben. √úberlegen, welche Parameter die Funktion braucht und ob diese Standardwerte ben√∂tigen. Parameter zwischen die runden Klammern schreiben. Funktionsk√∂rper (body), also die eigentliche Aufgabe der Funktion, hinschreiben. Wir brauchen f√ºr unsere Funktion nur einen Parameter. Zwar sind die Namen der Parameter nicht ganz so wichtig wie Namen der Funktionen. Trotzdem sollte man hier konsistent sein: bei einfachen Vektoren sind x, y, z etc. v√∂llig in Ordnung. Ansonsten sind Substantive ein guter Namensstil f√ºr Parameter. Wir wenden die Funktion jetzt auf unseren Datensatz an. my_data_trans_2 &lt;- data.frame(col1_trans = z_transofrm(my_data$col1), col2_trans = z_transofrm(my_data$col2), col2_trans = z_transofrm(my_data$col3)) summary(my_data_trans_2) ## col1_trans col2_trans col2_trans.1 ## Min. :-1.5978 Min. :-1.6695 Min. :-1.3982 ## 1st Qu.:-1.1326 1st Qu.:-0.7700 1st Qu.:-1.0361 ## Median : 0.1736 Median : 0.1148 Median : 0.2165 ## Mean : 0.0000 Mean : 0.0000 Mean : 0.0000 ## 3rd Qu.: 0.8247 3rd Qu.: 0.7749 3rd Qu.: 0.8191 ## Max. : 1.4644 Max. : 1.1549 Max. : 1.3470 sapply(my_data_trans_2, sd) ## col1_trans col2_trans col2_trans.1 ## 1 1 1 Der Code ist viel aufger√§umter und √ºbersichtlicher. Es ist viel klarer, was berechnet wird. 7.2 Fallunterscheidungen Manchmal m√∂chte man unterschiedliche Berechnung innerhalb einer Funktion durchf√ºhren, je nach aufgestellter Bedingung. Daszu brauchen wir eine Fallunterscheidung, die durch einen if-else Ausdruck definiert wird. Jede Fallunterscheidung hat die folgende Form, wobei die zweite Bedingung nicht zwingend notwendig ist. if (Bedingung1) { # Code, der ausgef√ºhrt wird, wenn die erste Bedingung1 stimmt } else if (Bedingung2) { # Code, der ausgef√ºhrt wird, wenn zweite Bedingung2 stimmt } else { # Code, der ausgef√ºhrt wird, wenn keine der Bedingungung stimmt } Achten Sie genau darauf, wie else if und else positioniert werden, n√§mlich zwischen den beiden geschweiften Klammern. Eine Fallunterscheidung kann auch mehr als zwei Bedingungen haben, aber man sollte nicht √ºbertreiben. Wenn die Anzahl der Bedingungen zu hoch ist, sollte man nachdenken, ob das Problem nicht anders als mit if-else gel√∂st werden kann. Wir schreiben eine Begr√º√üungsfunktion, die ja nach Tageszeit die richtige Begr√º√üung ausgibt. say_hello &lt;- function(my_time) { if (my_time == &#39;Morgen&#39;) { &#39;Guten Morgen&#39; } else if (my_time == &#39;Mittag&#39;) { &#39;Guten Tag&#39; } else if (my_time == &#39;Abend&#39;){ &#39;Guten Abend&#39; } else { &#39;In meiner Welt gibt es das nicht.&#39; } } Wir rufen die Funktion auf mit einmal mit Abend und einmal mit abend. say_hello(&#39;Abend&#39;) ## [1] &quot;Guten Abend&quot; say_hello(&#39;abend&#39;) ## [1] &quot;In meiner Welt gibt es das nicht.&quot; 7.3 for-Schleifen (for loops) Wenn wir unsere say_hello Funktion auf einen Vektor von Tageszeiten anwenden wollen, gibt es eine Warnung. say_hello(c(&#39;Morgen&#39;, &#39;Mittag&#39;, &#39;Abend&#39;)) ## Warning in if (my_time == &quot;Morgen&quot;) {: Bedingung hat L√§nge &gt; 1 und nur das erste ## Element wird benutzt ## [1] &quot;Guten Morgen&quot; Das liegt daran, dass die Auswertung der Bedingung eine Antwort der L√§nge 1 liefern muss: entweder TRUE, wenn die Bedingung stimmt, oder FALSE, wenn sie nicht stimmt. Bei einem Vektor ist die Antwort aber l√§nger als 1 und die Funktion benutzt nur die erste Stelle der Antwort. Man sagt auch, dass die Funktion say_hello nicht vektorisiert sei, sie kann also nicht von sich aus auf einem Vektor arbeiten. Damit man eine eine nicht vektorisierte Funktion auf einen Vektor anwenden kann, gibt es mehrere M√∂glichkeiten. Eine davon ist die sogen. for Schleife. Eine Schleife ist eine wiederholte Ausf√ºhrung von Code, man sagt auch Iteration. begruessung &lt;- c(&#39;Morgen&#39;, &#39;Mittag&#39;, &#39;Abend&#39;) # Vektor f√ºr Ergebnisse erstellen ergebnis &lt;- vector(mode = &#39;character&#39;, length = 3) # For Schleife √ºber die Zahlenfolge 1:3 mit Hilfe der Dummy-Variablen i for (i in 1:3) { ergebnis[i] &lt;- say_hello(begruessung[i]) } # Ergebnis ansehen ergebnis ## [1] &quot;Guten Morgen&quot; &quot;Guten Tag&quot; &quot;Guten Abend&quot; Eine for Schleife braucht drei Bestandteile: Einen Datencontainer, in unserem Fall den Vektor ergebnis, in dem die Ergebnisse der Schleifendurchl√§ufe gespeichert werden. Dieser Vektor muss vorher erstellt werden. Eine Dummy-Variable (Hilfsvariable), die in jedem Schleifendurchlauf einen anderen Wert annehmen wird. Dadurch entsteht erst die Schleife. Die Dummy-Variable bei uns hei√üt i und nimmt Werte zwischen 1 und 3 (also 1, 2 und 3) an. Es gibt also drei Schleifendurchg√§nge. Den Schleifen-K√∂rper, in unserem Fall die Funktion say_hello. Das ist der Code, der wiederholt ausgef√ºhrt werden soll. Sp√§ter werden wir effiziente Funktionen kennen lernen, die ohne Schleifen Funktionen wiederholt ausf√ºhren (iterieren) k√∂nnen. 7.4 Weiterf√ºhrende Literatur Ligges (2008), Kapitel 4.1 f√ºr technische Beschreibung des Aufrufs von Funktionen Dieses Kapitel orientiert sich stark an Wickham and Grolemund (2017), Kapitel 19 7.5 Inhalt der live Einf√ºhrung Funktionsaufruf Funktionen selbst schreiben if - else Bedingungen for Schleifen "]
]
