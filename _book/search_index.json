[
["index.html", "Datenanalyse mit R SoSe 2020 Kapitel 1 Vorwort 1.1 Organisatorisches 1.2 Sinn und Unsinn dieses Skripts", " Datenanalyse mit R SoSe 2020 Christina Bogner Version vom 26. Juli 2020 Kapitel 1 Vorwort ‚ÄúAnd honey, we‚Äôre gonna do it in style‚Äù ‚Äî Fools Garden 1.1 Organisatorisches Die Coronaviruspandemie ver√§ndert unser Leben und unser Lernen. Die UzK bittet Lehrende, zumindest zu Beginn des SoSe 2020 auf digitale Lernformen umzusteigen. Daher wird dieser Kurs als ein Onlinekurs beginnen. Abh√§ngig von der (sehr dynamischen) Lage werden wir im weiteren Kursverlauf das Format anpassen. Bitte seien Sie nachsichtig, wenn nicht alles so klappt, wie in Pr√§senzveranstaltungen. Wir m√ºssen aktuell alle sehr viel dazu lernen in Sachen digitale Lehre. Sie k√∂nnen sicher sein, dass das Geographische Institut bem√ºht ist, die Lehre so effizient wie m√∂glich weiter laufen zu lassen, damit Sie in Ihrem Studium fortfahren k√∂nnen. In dieser Veranstaltung werden wir folgende Werkzeuge verwenden: ILIAS: die Online-Lernplattform der UzK. Entweder sind Sie bereits automatisch in dem Kurs registriert oder werden von mir per Hand angemeldet. Campuswire: die Live-Chatplattform dient der allgemeinen Kommunikation und der Selbstorganisation des Lernens. Verwenden Sie diese, um Fragen mit Ihren Kommilitonen und mir zu diskutieren. Sie sollten eine Einladungsmail zu Campuswire erhalten haben. Zoom: die Videokonferenz-Software werden wir f√ºr live Einf√ºhrungen nutzen. Die Anmeldemodalit√§ten sind auf den Kursseiten in ILIAS erkl√§rt. 1.2 Sinn und Unsinn dieses Skripts Dieses Skript ist ein lebendiges Begleitdokument des Kurses. Es wird laufend angepasst und aktualisiert. Ich nutze verschiedene Farbk√§sten, um wichtige Stellen hervorzuheben: Infoblock Achtung, wichtig! Beispielblock Lernziele Zusammenfassung "],
["einfuehrung.html", "Kapitel 2 Der Kurs 2.1 Zuordnung zum Modul und Leistungsnachweis 2.2 Lernziele des Kurses 2.3 Was mir im Umgang miteinander wichtig ist", " Kapitel 2 Der Kurs 2.1 Zuordnung zum Modul und Leistungsnachweis Dieser Kurs geh√∂rt zum Modul Fachmethodik I oder Fachmethodik II und ist aus 4 SWS Praktikum und 2 SWS Seminar aufgebaut. Das wichtigste Ziel besteht darin, Ihnen einen sicheren Umgang mit R beizubringen. Den Leistungsnachweis bildet ein benoteter Praktikumsbericht. 2.2 Lernziele des Kurses Daten f√ºr Analysen vorbereiten eigene wiederverwendbare Skripte schreiben eigene Funktionen schreiben einfache Datenanalysen durchf√ºhren Daten visualisieren Ergebnisse reproduzierbar im Praktikumsbericht darstellen 2.3 Was mir im Umgang miteinander wichtig ist P√ºnktlichkeit bei live und Pr√§senzsitzungen Gute Vorbereitung durch erledigen der blenden learning Einheiten und Hausaufgaben Respektieren anderer Meinungen Offenheit gegen√ºber neuen Sichtweisen, Themen und Methoden Geduld mit sich selbst und den anderen üòÑ "],
["erste-schritte.html", "Kapitel 3 Erste Schritte in 3.1 Was ist R? 3.2 Was ist RStudio? 3.3 RStudio Cloud 3.4 Inhalt der live Einf√ºhrung", " Kapitel 3 Erste Schritte in Layout und Bedeutung einzelner Fenster in RStudio kennen Anweisungen aus dem Skript an die Konsole schicken R als Taschenrechner benutzen erste Funktionen aufrufen Objekte mit eckigen Klammern [ ] ansprechen R-Hilfeseiten aufrufen 3.1 Was ist R? R ist eine Programmiersprache f√ºr Datenanalyse und statistische Modellierung. Es ist frei verf√ºgbar (open source software) und neben Python einer der am meisten benutzten Programmiersprachen zur Datenanalyse und -visualisierung. R wurde von Ross Ihaka und Robert Gentleman 1996 ver√∂ffentlicht Ihaka and Gentleman (1996). Es gibt f√ºr R eine Vielzahl von Zusatzpaketen, die die Funktionalit√§t und die Einsatzm√∂glichkeiten enorm erweitern. Sie k√∂nnen R f√ºr Ihren Computer auf der offiziellen R-Seite https://www.r-project.org/ herunter laden und installieren. Auch die Pakete finden Sie dort unter CRAN (The Comprehensive R Archive Network). Auf den CRAN-Seiten finden Sie sogen. CRAN Task Views, eine √úbersicht √ºber Pakete in verschiedenen Themenbereichen. F√ºr den Umweltbereich sind folgende Paketsammlungen besonders relevant: Environmetrics: Analyse von Umweltdaten Multivariate: Multivariate Statistik Spatial: Analyse von r√§umlichen Daten TimeSeries: Zeitreihenanalyse Zu Beginn des Kurses, werden wir jedoch nicht auf Ihren lokalen Rechnern arbeiten, sondern in einer Cloud (s.u.). Das erm√∂glicht einen schnelleren Einstieg in R und bietet eine live Unterst√ºtzung durch den Dozenten beim Programmieren. Daher biete ich zu diesem fr√ºhen Zeitpunkt im Kurs keine Unterst√ºtzung bei der Installation. F√ºr die ganz Ungeduldigen, gibt es hier eine kurze Einleitung zur Installation 3.2 Was ist RStudio? RStudio Desktop ist eine Entwicklungsumgebung f√ºr R. Sie k√∂nnen die open source Version kostenlos f√ºr Ihren Rechner hier herunterladen. Es gibt eine live Einf√ºhrung in RStudio im Kurs. Zus√§tzlich k√∂nnen Sie hier ein Video dazu ansehen. 3.3 RStudio Cloud Zu Beginn des Kurses werden wir in der RStudio Cloud arbeiten. Sie sollten eine Einladungsmail zu unserem Kurs in der Cloud bekommen haben. Ich werde in der Cloud Projekte f√ºr Sie anlegen (assignment), die Skripte, Arbeitsanweisungen etc. beinhalten. Wenn Sie auf so ein Assignment klicken, wird f√ºr Sie automatische ein Kopie des Projekts erstellt, in der Sie dann arbeiten k√∂nnen. Der gro√üe Vorteil der Cloud ist, dass ich direkt in Ihre Projekte eingreifen kann, wenn es mal zu Fehlern kommt. W√§hrend ich in Ihrem Projekt arbeite, werden Sie kurz aus der R-Sitzung ausgeloggt, da die Cloud kein gleichzeitiges Arbeiten unterst√ºtzt. Nehmen Sie sich etwas Zeit, um die Cloud und die darin enthaltenen Tutorials kennen zu lernen. Sowohl in der RStudio Cloud als auch in einer lokalen Installation, ist Ihr RStudio so aufgebaut wie in Abbildung 3.1. Abbildung 3.1: Aufbau von RStudio 3.4 Inhalt der live Einf√ºhrung √úberblick √ºber RStudio R als Taschenrechner einfache Funktionen aufrufen Zuordnungen (assignments) Notation mit eckigen Klammern [ ] (array-Notation) Hilfeseiten aufrufen Funktionen, die wir in der Session nutzen werden: Funktion Bedeutung Beispielaufruf pi Zahl pi pi sin Sinus sin(2) cos Cosinus cos(2) sqrt Quadratwurzel sqrt(2) c (concatenate) F√ºgt Daten zu einem Vektor zusammen c(1,2,3,4) help.start √ñffnet ein Browser-Fenster mit diversen Handb√ºchern help.start() help.search Sucht nach einem Begriff in Hilfe-Dateien help.search('time') ?? alias help.search ??time help Sucht nach einer Funktion ?mean ? alias help() ?mean mean Mittelwert mean(c(1,2,3,4)) var Varianz var(c(1,2,3,4)) sd Standardabweichung sd(c(1,2,3,4)) sum Summe sum(c(1,2,3,4)) vector Generiert einen Vektor vector(length=3, mode='numeric') "],
["daten.html", "Kapitel 4 Daten in R 4.1 Datenstrukturen erzeugen 4.2 Arten von Daten in R 4.3 Objekt, sag mir wer du bist 4.4 Datenl√ºcken, Fehlschl√§ge etc. 4.5 Inhalt der live Einf√ºhrung", " Kapitel 4 Daten in R Daten einlesen mit read.table Datenstrukturen erstellen Typen von Daten in R abfragen Daten speichern mit write.table 4.1 Datenstrukturen erzeugen In R gibt es unterschiedliche Datenobjekte. Es ist wichtig, sich √ºber die Struktur (oder Typ) des Datenobjekts Gedanken zu machen. Denn diese bestimmt, was mit einem Objekt gemacht werden kann und ob Funktionen damit richtig umgehen k√∂nnen. Schlie√ülich ist es nicht egal, ob es sich bei einem Objekt um ein numerisches Objekt oder einfach Text (character) handelt. Die wichtigsten Datentypen sind Vektoren: hier gruppiert man gleichartige Elemente, z.B. Zahlen. Auch eine einzelne Zahl (ein Skalar) wird von R wie ein Vektor behandelt. Matrizen: zweidimensionale (Zeilen und Spalten) Datentabellen mit gleichartigen Elementen. Listen: k√∂nnen beliebige Elemente beliebiger L√§nge enthalten. Dataframes: zweidimensionale Datentabellen, die beliebige Elemente enthalten k√∂nnen. Die Spalten der Dataframes m√ºssen allerdings gleichartige Elemente enthalten. Dataframes sind eine Unterart von Listen. Neben diesen Hauptstrukturen gibt es Factor: ein besonderer Vektor f√ºr kategorielle Variablen Um diese Datenstrukturen zu erzeugen, gibt es jeweils eine Funktion mit gleichlautendem Namen. # Vektor erzeugen my_vect = vector(length = 3, mode = &#39;numeric&#39;) my_vect ## [1] 0 0 0 # Matrix erzeugen my_matrix = matrix(data = c(1:(3*4)), nrow = 3, ncol = 4) my_matrix ## [,1] [,2] [,3] [,4] ## [1,] 1 4 7 10 ## [2,] 2 5 8 11 ## [3,] 3 6 9 12 # Dataframe erzeugen my_dataframe = data.frame(&#39;Spalte_1&#39; = rep(&#39;Text&#39;, 10), &#39;Spalte_2&#39; = 1:10) my_dataframe ## Spalte_1 Spalte_2 ## 1 Text 1 ## 2 Text 2 ## 3 Text 3 ## 4 Text 4 ## 5 Text 5 ## 6 Text 6 ## 7 Text 7 ## 8 Text 8 ## 9 Text 9 ## 10 Text 10 # Liste erzeugen my_list = list(&#39;Schachtel_1&#39; = 3, &#39;Schachtel_2&#39; = my_dataframe, &#39;Schachtel_3&#39; = &#39;Noch mehr Text&#39;) my_list ## $Schachtel_1 ## [1] 3 ## ## $Schachtel_2 ## Spalte_1 Spalte_2 ## 1 Text 1 ## 2 Text 2 ## 3 Text 3 ## 4 Text 4 ## 5 Text 5 ## 6 Text 6 ## 7 Text 7 ## 8 Text 8 ## 9 Text 9 ## 10 Text 10 ## ## $Schachtel_3 ## [1] &quot;Noch mehr Text&quot; # Factor erzeugen my_factor = factor(c(&#39;R&#39;, &#39;RStudio&#39;, &#39;Cloud&#39;, &#39;Cloud&#39;, &#39;R&#39;, &#39;R&#39;)) my_factor ## [1] R RStudio Cloud Cloud R R ## Levels: Cloud R RStudio 4.2 Arten von Daten in R Die Datenstrukturen vector, data.frame usw. k√∂nnen unterschiedliche Arten von Daten enthalten. Name Beispiele raw 3A, FE logical TRUE, FALSE integer 1, 42, -3 numeric/double 3, 2.81, 6.032e23 complex 1.2+2.2i character ‚Äúfoo‚Äù 4.3 Objekt, sag mir wer du bist Um die Struktur und/oder Datenart abzufragen, verwendet man class, typeof, mode und storage.mode. class(my_vect) ## [1] &quot;numeric&quot; typeof(my_vect) ## [1] &quot;double&quot; class(my_dataframe) ## [1] &quot;data.frame&quot; typeof(my_dataframe) ## [1] &quot;list&quot; Mit str kann man das Innenleben eines Objekts anzeigen. Das ist besonders wichtig nach dem Einlesen von Daten, um das Ergebnis des Einlesens zu kontrollieren. Dabei kontrolliert man, dass z.B. alle numerischen Spalten auch als Zahlen eingelesen wurden und nichts schief gegangen ist. str(my_dataframe) ## &#39;data.frame&#39;: 10 obs. of 2 variables: ## $ Spalte_1: chr &quot;Text&quot; &quot;Text&quot; &quot;Text&quot; &quot;Text&quot; ... ## $ Spalte_2: int 1 2 3 4 5 6 7 8 9 10 Weiter Funktionen, die Auskunft √ºber Objekte geben sind length, sinnvoll auf nur Vektoren und Listen, und dim, sinnvoll auf zweidimensionalen Datenobjekten. Wenn Sie versuchen, dim auf einem Vektor aufzurufen, gibt es NULL (s.u.), weil Vektoren keine Dimensionen haben. Wenn Sie length auf einem data.frame aufrufen, bekommen Sie die Anzahl der Dimensionen, n√§mlich 2. Das sind keine besonders spannenden Informationen üòÑ. length(my_vect) ## [1] 3 dim(my_vect) ## NULL length(my_dataframe) ## [1] 2 dim(my_dataframe) ## [1] 10 2 4.4 Datenl√ºcken, Fehlschl√§ge etc. Datenl√ºcken werden in R mit NA kodiert, Fehlschl√§ge bei Berechnungen mit NaN (not a number) und Vektoren der L√§nge 0 mit NULL. Letzteres wird h√§ufig beim Aufruf von Funktionen benutzt, wenn man bestimmte Parameter ausschalten m√∂chte. Die Benutzung muss aber immer in der Hilfe zur jeweiligen Funktion nachgeschlagen werden. 4.5 Inhalt der live Einf√ºhrung Daten einlesen und data.frame erstellen: Aufgabe 9.2.1 Funktionen, die wir in der Session nutzen werden: Funktion Bedeutung Beispielaufruf read.table Liest Daten aus einer Datei ein. read.table(file= 'Daten.txt', header=TRUE) ls Zeigt den Inhalt des Workspaces. ls head Zeigt den ersten Teil eines Objekts. head(x) tail Zeigt den letzten Teil eines Objekts. tail(x) str Zeigt die Struktur (Innenleben) eines Objekts an str(my_dataframe) length Gibt die L√§nge eines Objekts. length(x) dim Gibt die Dimension eines Objekts (Reihenfolge: Zeilen, Spalten) dim(x) seq Erstellt eine regelm√§√üige Reihe. seq(from=-2, to=4, by=0.1) data.frame Erstellt eine Datentabelle. data.frame(x,y,z) colnames, rownames Benennt Spalten bzw. Zeilen eines Datenobjekts. colnames(x) rm L√∂scht Objekte aus dem Workspace. rm(x) summary Fasst ein Objekt zusammen. summary(x) table Erstellt eine H√§ufigkeitstabelle. table(x) which Gibt die TRUE-Indices eines logischen Objekts. which(LETTERS == 'R') history Zeigt die Liste mit ausgef√ºhrten Befehlen der Session. history write.table Speichert Datenobjekte als Tabelle ab. write.table(x, file='Tabelle.txt') save.image Speichert den Workspace. save.image(file= 'RSession.Rdata') savehistory Speichert die History. savehistory(file= 'Myhistory.Rhistory') "],
["visualisieren.html", "Kapitel 5 Daten visualisieren I: Einfache Grafiken 5.1 Plotten mit R-Basisfunktionen 5.2 Tuning mit par 5.3 Inhalt der live Einf√ºhrung", " Kapitel 5 Daten visualisieren I: Einfache Grafiken Einfache Grafiken erstellen Grafiken beschriften und speichern Die Arbeitsweise der Funktion par beschreiben Die grafischen Parameter f√ºr Randgr√∂√üe, Farbe, Schrift- und Symbolgr√∂√üe einstellen Unterschiede zwischen high-level und low-level Grafikfunktionen erkl√§ren Grafiken mit mehreren Plots erstellen 5.1 Plotten mit R-Basisfunktionen F√ºr Grafikverliebte und Neugierige empfehle ich die Kapitel 2 und 3 in Murrell (2006). 5.1.1 High-level Grafikfunktion plot und low-level Grafikfunktion lines Ein Streudiagramm stellt zwei numerische Variablen gegeneinander dar. Wir betrachten Klimadaten der Station K√∂ln-Bonn, die man beim Deutschen Wetterdienst herunterladen kann (https://www.dwd.de/DE/leistungen/klimadatendeutschland/klimadatendeutschland.html). Sie k√∂nnen den Code aus den Chunks leicht herauskopieren und in RStudio laufen lassen (rechts oben in den Chunks auf das Symbol copy to clipboard klicken). Wir lesen die Daten ein und sehen uns deren Struktur an. meteo &lt;- read.table(&#39;produkt_klima_monat_20181001_20200430_02667.txt&#39;, header = T, sep = &#39;;&#39;) str(meteo) ## &#39;data.frame&#39;: 19 obs. of 17 variables: ## $ STATIONS_ID : int 2667 2667 2667 2667 2667 2667 2667 2667 2667 2667 ... ## $ MESS_DATUM_BEGINN: int 20181001 20181101 20181201 20190101 20190201 20190301 20190401 20190501 20190601 20190701 ... ## $ MESS_DATUM_ENDE : int 20181031 20181130 20181231 20190131 20190228 20190331 20190430 20190531 20190630 20190731 ... ## $ QN_4 : int 3 3 3 3 3 3 3 3 3 3 ... ## $ MO_N : num 4.76 5.51 6.49 6.66 4.79 5.62 4.56 5.37 3.85 4.95 ... ## $ MO_TT : num 12.01 7.31 5.64 2.41 6.4 ... ## $ MO_TX : num 17.58 10.95 8.47 4.74 12 ... ## $ MO_TN : num 6.41 3.51 2.61 -0.26 1.12 ... ## $ MO_FK : num 2.42 2.57 2.68 2.84 2.54 3.06 2.53 2.32 2.4 2.23 ... ## $ MX_TX : num 26.7 19.2 15 8.8 21 20.4 25.9 24.3 36.2 40.3 ... ## $ MX_FX : num 15.3 16.5 18.9 22.8 18.7 28.8 19.5 16.5 26.1 14.6 ... ## $ MX_TN : num 0.4 -4.3 -4.9 -10.7 -3.5 -2.8 -2.3 -1.8 7.3 4.4 ... ## $ MO_SD_S : num 145.4 74.2 33.8 38.2 127.3 ... ## $ QN_6 : int 9 9 9 3 3 3 3 3 3 3 ... ## $ MO_RR : num 26.5 25 101.9 101.8 30 ... ## $ MX_RS : num 6.9 9.7 15.7 22.3 12.3 18.2 21.4 10.6 8.8 11.9 ... ## $ eor : chr &quot;eor&quot; &quot;eor&quot; &quot;eor&quot; &quot;eor&quot; ... Uns interessieren hier nur die Spalten MO_TT, MO_TN, MO_TX und MESS_DATUM_BEGINN. Das sind jeweils die Monatsmittel der Lufttemperatur in 2 m H√∂he, Monatsmittel des Minimums der Lufttemperatur, Monatsmittel des Maximums der Lufttemperatur und der Beginn der jeweiligen Messperiode (d.h. des Kalendermonats). Um die Daten als Zeitreihen darstellen zu k√∂nnen, wandeln wir die Spalte MESS_DATUM_BEGINN in ein richtiges Zeitobjekt (d.h. ein Objekt der Klasse Date). Das geht mit der Funktion as.Date. Der Parameter format beschreibt den Aufbau des Datums im Objekt meteo: erst steht das Jahr mit 4 Zeichen (z.B. 2018), dann folgt der Monat mit 2 Zeichen (z.B. 01) und dann der Tag mit 2 Zeichen (z.B. 01). N√§heres zu Datumsformaten finden Sie mit ?strptime. my_date &lt;- as.Date(as.character(meteo$MESS_DATUM_BEGINN), format = &#39;%Y%m%d&#39;) my_date ## [1] &quot;2018-10-01&quot; &quot;2018-11-01&quot; &quot;2018-12-01&quot; &quot;2019-01-01&quot; &quot;2019-02-01&quot; &quot;2019-03-01&quot; ## [7] &quot;2019-04-01&quot; &quot;2019-05-01&quot; &quot;2019-06-01&quot; &quot;2019-07-01&quot; &quot;2019-08-01&quot; &quot;2019-09-01&quot; ## [13] &quot;2019-10-01&quot; &quot;2019-11-01&quot; &quot;2019-12-01&quot; &quot;2020-01-01&quot; &quot;2020-02-01&quot; &quot;2020-03-01&quot; ## [19] &quot;2020-04-01&quot; Es sind Daten von Oktober 2018 bis April 2020. Wir erstellen ein Streudiagramm mit der Funktion plot. Mit den Parametern xlab und ylab lassen sich die beiden Achsen beschriften und main f√ºgt einen Titel dazu. Der Parameter type bestimmt die Wahl der Symbole; hier benutzen wir type = b f√ºr both, also sowohl Punkte als auch Linien. plot(my_date, meteo$MO_TT, type = &#39;b&#39;, xlab = &#39;Zeit&#39;, ylab = &#39;Temperatur [¬∞C]&#39;, main = &#39;Klimadaten der DWD-Station K√∂ln-Bonn&#39;) Die Funktion plot ist eine sogen. high-level Grafikfunktion. Das bedeutet, dass sie alle Schritte des Plottens √ºbernimmt: sie √∂ffnet ein neues Grafikfenster (ein Device), berechnet die Gr√∂√üe der Plotfl√§che und der R√§nder (s. unten), berechnet die Ausdehnung der Achsen und die beste Achseneinteilung und plottet Ihre Daten. Daneben gibt es low-level Grafikfunktionen, die nur in ein bestehendes Device plotten k√∂nnen. Wir wollen zu unserer Grafik nun die Minimum- und die Maximumtemperatur dazu plotten. plot(my_date, meteo$MO_TT, type = &#39;b&#39;, xlab = &#39;Zeit&#39;, ylab = &#39;Temperatur [¬∞C]&#39;, main = &#39;Klimadaten der DWD-Station K√∂ln-Bonn&#39;) # Minimumtemperatur in blau lines(my_date, meteo$MO_TN, col = &#39;blue&#39;) # Maximumtemperatur in rot lines(my_date, meteo$MO_TX, col = &#39;red&#39;) Dass lines nur eine low-level Grafikfunktion ist, erkennen Sie daran, dass sie nicht in der Lage ist, den Bereich auf der y-Achse zu vergr√∂√üern, um alle Daten sichtbar zu machen. Das kann nur plot. Daher muss der Bereich bereits in plot richtig festgelegt werden. Das macht der Parameter ylim. plot(my_date, meteo$MO_TT, type = &#39;b&#39;, xlab = &#39;Zeit&#39;, ylab = &#39;Temperatur [¬∞C]&#39;, main = &#39;Klimadaten der DWD-Station K√∂ln-Bonn&#39;, ylim = c(0, 30)) # Minimumtemperatur in rot lines(my_date, meteo$MO_TN, col = &#39;blue&#39;) # Maximumtemperatur in blau lines(my_date, meteo$MO_TX, col = &#39;red&#39;) Wenn in einer Grafik mehrere Elemente dargestellt werden, ben√∂tigt man eine Legende. Das erledigt die * low-level* Grafikfunktion legend. plot(my_date, meteo$MO_TT, type = &#39;b&#39;, xlab = &#39;Zeit&#39;, ylab = &#39;Temperatur [¬∞C]&#39;, main = &#39;Klimadaten der DWD-Station K√∂ln-Bonn&#39;, ylim = c(0, 30)) # Minimumtemperatur in rot lines(my_date, meteo$MO_TN, col = &#39;blue&#39;) # Maximumtemperatur in blau lines(my_date, meteo$MO_TX, col = &#39;red&#39;) legend(&#39;topright&#39;, legend = c(&#39;Mittelwert&#39;, &#39;Minimum&#39;, &#39;Maximum&#39;), col = c(&#39;black&#39;, &#39;red&#39;, &#39;blue&#39;), pch = c(1, NA, NA), lty = 1) Der Parameter lty steht f√ºr line type und die 1 bedeutet durchgezogene Linie. Mit pch legend wir die Art des Symbols fest; hier steht die 1 f√ºr das Standardsymbol ‚Äúoffener Kreis‚Äù. Die Funktion legend hat viele M√∂glichkeiten und es lohnt sich, in die Hilfe zu sehen ?legend. 5.1.2 √úberblick √ºber die wichtigsten high-level und low-level Grafikfunktionen Die wichtigsten high-level Grafikfunktionen nach Ligges (2008), ver√§ndert: Funktion Beschreibung plot kontextabh√§ngig ‚Äì generische Funktion mit vielen Methoden barplot S√§ulendiagramm boxplot Boxplot contour H√∂henlinien-Plot coplot Conditioning-Plots: Plots zweier Variablen aufgeteilt nach Werten einer dritten curve Funktionen zeichnen dotchart Dotplots (nach Cleveland) hist Histogramm image Bilder (3. Dimension als Farbe) mosaicplot Mosaikplots (kategorielle Daten) pairs Streudiagramm-Matrix persp perspektivische Fl√§chen qqnorm und qqplot QQ‚ÄìPlot Die wichtigsten low-level Grafikfunktionen nach Ligges (2008), ver√§ndert: Funktion Beschreibung abline F√ºgt eine Linie hinzu; diese kann horizontal, vertikal oder √ºber Steigung und Achsenabschnitt definiert werden arrows Pfeile axis Achsen grid Gitternetz legend Legende lines Linien (schrittweise) mtext Text in den R√§ndern plot.new Grafik initialisieren plot.window Koordinatensystem initialisieren points Punkte polygon (ausgef√ºllte) Polygone pretty berechnet ‚Äúh√ºbsche‚Äù Einteilung der Achsen segments Linien (vektorwertig) text Text title Beschriftung 5.2 Tuning mit par Zur Vertiefung dieses Kapitels, empfehle ich Ligges (2008), Kapitel 8.1.3. Die Grafikebene in R ist aufgeteilt in drei Regionen (Abbildung 5.1) und hat innere und √§u√üere R√§nder. Die R√§nder werden von unten im Gegenuhrzeigersinn durchnummeriert. Abbildung 5.1: Aufteilung der Grafikfl√§che (Ligges 2008). Mit der Funktion par lassen sich sehr viele Einstellung der Grafik ver√§ndern. Viele Einstellungen √ºbergibt die Funktion plot selbst√§ndig an par, zu.B. log (Logarithmieren der Achsen), cex (Gr√∂√üe eines Punkts) oder col (Farbe). Andere k√∂nnen aber nur durch Aufrufen der Funktion par ver√§ndert werden. Dazu geh√∂ren die inneren R√§nder mar und die √§u√üeren R√§nder oma, die Aufteilung der Grafikebene mit mfrow oder mfcol. Richtige Benutzung von par: Parameter setzen: op &lt;- par( ‚Ä¶ ) plotten Parameter auf Standard zur√ºck setzen: par(op) Die Zuweisung op &lt;- par( ... ) speichert die Standardeinstellungen im Objekt par, bevor Sie sie √§ndern. Der Aufruf par(op) setzt Ihre √Ñnderungen zur√ºck. Das ist sehr praktisch, wenn Sie z.B. die Aufteilung der Grafikebene nicht mehr ben√∂tigen. Wenn Sie die Parameter nicht zur√ºcksetzen, bleiben diese bestehen, bis das Grafikfenster geschlossen wird (z.B. mit dev.off()). Um die R√§nder zu ver√§ndern, rufen wir par auf und beschneiden die R√§nder, damit Sie den Unterschied erkennen k√∂nnen. op &lt;- par(mar = c(1, 1, 1, 1)) plot(my_date, meteo$MO_TT, type = &#39;b&#39;, xlab = &#39;Zeit&#39;, ylab = &#39;Temperatur [¬∞C]&#39;, main = &#39;Klimadaten der DWD-Station K√∂ln-Bonn&#39;, ylim = c(0, 30)) # Minimumtemperatur in rot lines(my_date, meteo$MO_TN, col = &#39;blue&#39;) # Maximumtemperatur in blau lines(my_date, meteo$MO_TX, col = &#39;red&#39;) Die Achsenbeschriftungen und die Zahlen haben jetzt nicht mehr genug Platz und verschwinden. Die Gr√∂√üe der R√§nder wird in Zeilen angegeben, ist also relativ zur Gesamtgr√∂√üe. Die Standardeinstellung ist c(5, 4, 4, 2) + 0.1. Einige h√§ufig genutzte Argumente in Grafikfunktionen und in par (nach Ligges 2008, ver√§ndert). Schlagen Sie die Erkl√§rungen dazu immer in ?par oder ?plot nach. Funktion Beschreibung axes Achsen sollen (nicht) eingezeichnet werden bg Hintergrundfarbe cex Gr√∂√üe eines Punktes bzw. Buchstaben col Farben las Ausrichtung der Achsenbeschriftung log Logarithmierte Darstellung lty, lwd Linientyp (gestrichelt, ‚Ä¶) und Linienbreite main √úberschrift mar Gr√∂√üe der inneren R√§nder f√ºr Achsenbeschriftung etc. mfcol, mfrow mehrere Grafiken in einem Bild pch Symbol f√ºr einen Punkt type Typ (l f√ºr Linie, p f√ºr Punkt, b f√ºr beides, n f√ºr nichts) usr Ausma√üe der Achsen auslesen xlab, ylab x-/y-Achsenbeschriftung xlim, ylim zu plottender Bereich in x-/y- Richtung xpd in die R√§nder hinein zeichnen 5.3 Inhalt der live Einf√ºhrung plot, barplot, mfrow Aufgaben 9.3.1, 9.3.2 und 9.3.3. Speichern als pdf "],
["reproduzieren.html", "Kapitel 6 Reproduzierbare Forschung 6.1 Warum Reproduzierbarkeit in der Forschung wichtig ist 6.2 Literate Programming Idee von Donald Knuth 6.3 Reproduzierbare Berichte mit R Markdown 6.4 Wichtigste Regeln f√ºr Reproduzierbarkeit 6.5 Weiterf√ºhrende Videos und Literatur 6.6 Inhalt der live Einf√ºhrung", " Kapitel 6 Reproduzierbare Forschung Wichtigkeit der Reproduzierbarkeit erkl√§ren Begriff literate programming definieren Aufbau einer RMarkdown-Datei erkl√§ren Einen einfachen ersten reproduzierbaren Bericht schreiben 6.1 Warum Reproduzierbarkeit in der Forschung wichtig ist 6.2 Literate Programming Idee von Donald Knuth Die Idee, dass man den Code und die dazugeh√∂rige Interpretation (Text, Bericht etc.) nicht von einander trennen sollte, geht auf Knuth (1984) zur√ºck. Mit Literate Programming meinte Knuth, dass Programme auch nichts anderes wie literatirsche Werke sind. Er setzte den Fokus darauf, mit Programmen menschlichen Benutzern zu erkl√§ren, was man den Computer machen lassen m√∂chte. Also weg vom computer- hin zum menschzentrierten Zugang. So wird Programmieren und in unserem Fall die Datenanalyse verst√§ndlich und vor allem reproduzierbar. Leider ist es in unserer modernen Forschungslandschaft immer noch nicht Standard. Das Trennen von Analyseergebnissen und Berichten (Forschungsartikeln) sorgt f√ºr viele (unendeckte und unn√∂tige) Fehler und Frust. 6.3 Reproduzierbare Berichte mit R Markdown R hat sein eigenes System von reproduzierbaren Berichten, genannt R Markdown (Xie, Allaire, and Grolemund 2018). Es ist benutzerfreundlich und erm√∂glicht unterschiedliche Formate von Berichten, wie HTML-Dokumente, PDF-Dateien, Pr√§sentationsfolien usw. Es wird Sie vielleicht √ºberraschen, aber das Skript, das Sie gerade lesen ist nichts anderes als ein ‚Äúliterarisch‚Äù programmierter Bericht in R Bookdown (Xie 2016), einem R-Paket speziell f√ºr lange R Markdown-Dokumente. Wir werden vor allem mit R Notebooks arbeiten, die eine gute Interaktion zwischen dem geschriebenen Text und dem R-Code erm√∂glichen. Das Notebook kann sowohl in ein HTML-Dokument als auch in PDF oder Word als endg√ºltiges Berichtdokument umgewandlet werden. Diesen Prozess nennt man knit (der Knopf in RStudio mit dem Wollkn√§uel). 6.4 Wichtigste Regeln f√ºr Reproduzierbarkeit 6.5 Weiterf√ºhrende Videos und Literatur Die Playlist zu Reporducible Research finden Sie hier. Report Writing for Data Science in R (Peng 2019) (auf ILIAS) 6.6 Inhalt der live Einf√ºhrung Erstellen eines einfachen R Notebooks R-Code Chunks Einfache Layoutelemente: √úberschriften, Listen, fett und kursiv "],
["funktionen.html", "Kapitel 7 Funktionen 7.1 Eigene Funktionen schreiben 7.2 Fallunterscheidungen 7.3 for-Schleifen (for loops) 7.4 Weiterf√ºhrende Literatur 7.5 Inhalt der live Einf√ºhrung", " Kapitel 7 Funktionen Den Aufbau von Funktionen in R beschreiben Den Aufruf von Funktionen in R erkl√§ren Einfache Funktionen selbst schreiben Fallunterscheidungen Schleifen Was genau Funktionen sind und wie man sie in R aufruft, lesen Sie bitte bei Ligges (2008) in Kapitel 4.1 nach. In diesem Kapitel des Skripts geht es um das Schreiben der eigenen Funktionen, Fallunterscheidungen mit if-else und for Schleifen. 7.1 Eigene Funktionen schreiben Funktionen sind eine gro√üartige M√∂glichkeit, sich das Leben einfacher zu machen. Sie k√∂nnen repetitive Aufgaben erledigen, ohne dass wir st√§ndig mit Copy und Paste hantieren m√ºssen, machen unsere Notebooks √ºbersichtlich und helfen, Fehler und Inkonsistenzen zu vermeiden. Als Faustregel gilt: wenn Sie ein St√ºck Code mehr als 2 Mal kopieren und ab√§ndern, wird es Zeit f√ºr eine Funktion üòÑ. Schauen wir uns ein Beispiel an. Als erstes w√ºrfeln wir ein paar Daten aus der Gleichverteilung mit unterschiedlichen Minima und Maxima und sehen uns die Zusammenfassung und die Standardabweichungen an. my_data &lt;- data.frame(col1 = runif(20, min = 3, max = 10), col2 = runif(20, min = 7, max = 12), col3 = runif(20, min = 13, max = 100)) summary(my_data) ## col1 col2 col3 ## Min. :3.375 Min. : 7.017 Min. :13.47 ## 1st Qu.:5.281 1st Qu.: 7.507 1st Qu.:65.19 ## Median :8.193 Median : 8.448 Median :83.88 ## Mean :7.380 Mean : 8.986 Mean :72.94 ## 3rd Qu.:9.604 3rd Qu.:10.233 3rd Qu.:90.84 ## Max. :9.955 Max. :11.842 Max. :99.34 sapply(my_data, sd) ## col1 col2 col3 ## 2.405314 1.670579 27.063113 Ich m√∂chte die Daten so transformieren, dass alle Variablen im Datensatz (d.h. Spalten) einen Mittelwert von 0 und eine Standardabweichung von 1 haben. Dazu ziehe ich den Mittelwert ab und teile durch die Standardabweichung. Das ist eine klassische Transformation (manchmal \\(z\\)-Transformation genannt), die manche Analysemethoden (z.B. Hauptkomponentenanalyse) als Vorbehandlung der Daten verlangen. Erst einmal das Naheliegende: Transformation per Copy und Paste. my_data_trans &lt;- data.frame(col1_trans = (my_data$col1 - mean(my_data$col1))/sd(my_data$col1), col2_trans = (my_data$col2 - mean(my_data$col2))/sd(my_data$col1), col3_trans = (my_data$col3 - mean(my_data$col3))/sd(my_data$col3)) Haben Sie den Fehler bemerkt? Ich habe einmal vergessen eine 1 durch eine 2 zu ersetzten. Das merke ich aber nur, wenn ich mir das Ergebnis ansehen. Die Standardabweichung in col2_trans ist nicht gleich 1. summary(my_data_trans) ## col1_trans col2_trans col3_trans ## Min. :-1.6647 Min. :-0.8189 Min. :-2.1975 ## 1st Qu.:-0.8725 1st Qu.:-0.6151 1st Qu.:-0.2865 ## Median : 0.3381 Median :-0.2239 Median : 0.4042 ## Mean : 0.0000 Mean : 0.0000 Mean : 0.0000 ## 3rd Qu.: 0.9247 3rd Qu.: 0.5180 3rd Qu.: 0.6613 ## Max. : 1.0708 Max. : 1.1873 Max. : 0.9754 sapply(my_data_trans, sd) ## col1_trans col2_trans col3_trans ## 1.0000000 0.6945369 1.0000000 So etwas passiert sehr schnell und wird durch das Schreiben einer Funktion vermieden. Jede Funktionsdefinition beginnt mit der Wahl des Namens. Es ist eine gute Idee, sich einen konsistenten und sauberen Stil gleich am Anfang anzugew√∂hnen. Seien Sie nett zu Ihrem zuk√ºnftigen Ich und anderen Menschen, die Ihren Code lesen werden üòÑ. Es ist ein guter Stil, Verben als Funktionsnamen zu nutzen, die beschreiben, was eine Funktion macht. In jedem Fall, w√§hlen Sie keine Namen, die schon f√ºr Funktionen oder Variablen vergeben sind! Das w√ºrde die urspr√ºnglichen Funktionen oder Variablen einfach √ºberschreiben. Wir nennen unsere Funktion z_transform, weil sie Daten \\(z\\)-transformiert. Bei zusammengesetzten Namen sollten Sie den Unterstrich verwenden. Das macht den Namen einfacher zu lesen. z_transofrm &lt;- function(x) { (x - mean(x))/sd(x) } Bei jeder Funktionsdefinition arbeiten Sie drei Schritte ab: Namen finden und das Skelett aus Name_der_Funktion &lt;- function() {} hin schreiben. √úberlegen, welche Parameter die Funktion braucht und ob diese Standardwerte ben√∂tigen. Parameter zwischen die runden Klammern schreiben. Funktionsk√∂rper (body), also die eigentliche Aufgabe der Funktion, hinschreiben. Wir brauchen f√ºr unsere Funktion nur einen Parameter. Zwar sind die Namen der Parameter nicht ganz so wichtig wie Namen der Funktionen. Trotzdem sollte man hier konsistent sein: bei einfachen Vektoren sind x, y, z etc. v√∂llig in Ordnung. Ansonsten sind Substantive ein guter Namensstil f√ºr Parameter. Wir wenden die Funktion jetzt auf unseren Datensatz an. my_data_trans_2 &lt;- data.frame(col1_trans = z_transofrm(my_data$col1), col2_trans = z_transofrm(my_data$col2), col2_trans = z_transofrm(my_data$col3)) summary(my_data_trans_2) ## col1_trans col2_trans col2_trans.1 ## Min. :-1.6647 Min. :-1.1791 Min. :-2.1975 ## 1st Qu.:-0.8725 1st Qu.:-0.8857 1st Qu.:-0.2865 ## Median : 0.3381 Median :-0.3224 Median : 0.4042 ## Mean : 0.0000 Mean : 0.0000 Mean : 0.0000 ## 3rd Qu.: 0.9247 3rd Qu.: 0.7459 3rd Qu.: 0.6613 ## Max. : 1.0708 Max. : 1.7094 Max. : 0.9754 sapply(my_data_trans_2, sd) ## col1_trans col2_trans col2_trans.1 ## 1 1 1 Der Code ist viel aufger√§umter und √ºbersichtlicher. Es ist viel klarer, was berechnet wird. 7.2 Fallunterscheidungen Manchmal m√∂chte man unterschiedliche Berechnung innerhalb einer Funktion durchf√ºhren, je nach aufgestellter Bedingung. Daszu brauchen wir eine Fallunterscheidung, die durch einen if-else Ausdruck definiert wird. Jede Fallunterscheidung hat die folgende Form, wobei die zweite Bedingung nicht zwingend notwendig ist. if (Bedingung1) { # Code, der ausgef√ºhrt wird, wenn die erste Bedingung1 stimmt } else if (Bedingung2) { # Code, der ausgef√ºhrt wird, wenn zweite Bedingung2 stimmt } else { # Code, der ausgef√ºhrt wird, wenn keine der Bedingungung stimmt } Achten Sie genau darauf, wie else if und else positioniert werden, n√§mlich zwischen den beiden geschweiften Klammern. Eine Fallunterscheidung kann auch mehr als zwei Bedingungen haben, aber man sollte nicht √ºbertreiben. Wenn die Anzahl der Bedingungen zu hoch ist, sollte man nachdenken, ob das Problem nicht anders als mit if-else gel√∂st werden kann. Wir schreiben eine Begr√º√üungsfunktion, die ja nach Tageszeit die richtige Begr√º√üung ausgibt. say_hello &lt;- function(my_time) { if (my_time == &#39;Morgen&#39;) { &#39;Guten Morgen&#39; } else if (my_time == &#39;Mittag&#39;) { &#39;Guten Tag&#39; } else if (my_time == &#39;Abend&#39;){ &#39;Guten Abend&#39; } else { &#39;In meiner Welt gibt es das nicht.&#39; } } Wir rufen die Funktion auf mit einmal mit Abend und einmal mit abend. say_hello(&#39;Abend&#39;) ## [1] &quot;Guten Abend&quot; say_hello(&#39;abend&#39;) ## [1] &quot;In meiner Welt gibt es das nicht.&quot; 7.3 for-Schleifen (for loops) Wenn wir unsere say_hello Funktion auf einen Vektor von Tageszeiten anwenden wollen, gibt es eine Warnung. say_hello(c(&#39;Morgen&#39;, &#39;Mittag&#39;, &#39;Abend&#39;)) ## Warning in if (my_time == &quot;Morgen&quot;) {: Bedingung hat L√§nge &gt; 1 und nur das erste ## Element wird benutzt ## [1] &quot;Guten Morgen&quot; Das liegt daran, dass die Auswertung der Bedingung eine Antwort der L√§nge 1 liefern muss: entweder TRUE, wenn die Bedingung stimmt, oder FALSE, wenn sie nicht stimmt. Bei einem Vektor ist die Antwort aber l√§nger als 1 und die Funktion benutzt nur die erste Stelle der Antwort. Man sagt auch, dass die Funktion say_hello nicht vektorisiert sei, sie kann also nicht von sich aus auf einem Vektor arbeiten. Damit man eine eine nicht vektorisierte Funktion auf einen Vektor anwenden kann, gibt es mehrere M√∂glichkeiten. Eine davon ist die sogen. for Schleife. Eine Schleife ist eine wiederholte Ausf√ºhrung von Code, man sagt auch Iteration. begruessung &lt;- c(&#39;Morgen&#39;, &#39;Mittag&#39;, &#39;Abend&#39;) # Vektor f√ºr Ergebnisse erstellen ergebnis &lt;- vector(mode = &#39;character&#39;, length = 3) # For Schleife √ºber die Zahlenfolge 1:3 mit Hilfe der Dummy-Variablen i for (i in 1:3) { ergebnis[i] &lt;- say_hello(begruessung[i]) } # Ergebnis ansehen ergebnis ## [1] &quot;Guten Morgen&quot; &quot;Guten Tag&quot; &quot;Guten Abend&quot; Eine for Schleife braucht drei Bestandteile: Einen Datencontainer, in unserem Fall den Vektor ergebnis, in dem die Ergebnisse der Schleifendurchl√§ufe gespeichert werden. Dieser Vektor muss vorher erstellt werden. Eine Dummy-Variable (Hilfsvariable), die in jedem Schleifendurchlauf einen anderen Wert annehmen wird. Dadurch entsteht erst die Schleife. Die Dummy-Variable bei uns hei√üt i und nimmt Werte zwischen 1 und 3 (also 1, 2 und 3) an. Es gibt also drei Schleifendurchg√§nge. Den Schleifen-K√∂rper, in unserem Fall die Funktion say_hello. Das ist der Code, der wiederholt ausgef√ºhrt werden soll. Sp√§ter werden wir effiziente Funktionen kennen lernen, die ohne Schleifen Funktionen wiederholt ausf√ºhren (iterieren) k√∂nnen. 7.4 Weiterf√ºhrende Literatur Ligges (2008), Kapitel 4.1 f√ºr technische Beschreibung des Aufrufs von Funktionen Dieses Kapitel orientiert sich stark an Wickham and Grolemund (2017), Kapitel 19 7.5 Inhalt der live Einf√ºhrung Funktionsaufruf Funktionen selbst schreiben Aufgabe 9.5.2: if - else Bedingungen und for Schleifen "],
["tidyverse.html", "Kapitel 8 Tidyverse 8.1 Grundpakete 8.2 Der Workflow 8.3 Weiterf√ºhrende Literatur und Videos 8.4 Inhalt der live Einf√ºhrung", " Kapitel 8 Tidyverse Kernpakete aus tidyverse benennen ein einfaches Workflow (Daten einlesen, zusammenfassen, darstellen) mit tidyverse durchf√ºhren Funktionen des Pakets dplyr f√ºr Datentransformation anwenden tidyverse ist eine Sammlung von R-Pakete, die explizit f√ºr Datenanalyse entwickelt wurden (https://www.tidyverse.org/). tidyverse versucht durch gemeinsame Philosophie in Design, Grammatik und Datenstruktur die Datenanalyse zu erleichtern (https://design.tidyverse.org/). Auch wenn tidyverse auf den ersten Blick etwas fremd erscheint, es ist ein Teil von R, kein eigenes Universum. Es ist also v√∂llig in Ordnung, R-Basisfunktionen mit Funktionen aus tidyverse zu mischen. Das wichtigste Einf√ºhrungsbuch zu tidyverse ist sicherlich R4DS: ‚ÄúR for Data Science‚Äù (Wickham and Grolemund 2017), das Sie kostenlos online lesen k√∂nnen (https://r4ds.had.co.nz/). 8.1 Grundpakete tidyverse enth√§lt folgende Grundpakete, die alle installiert werden, wenn Sie install.packages('tidyverse') eingeben. Paketname Kurzbeschreibung ggplot2 Visualisierung dplyr Datentransformation tidyr Datenbereinigung readr Daten einlesen purrr Funktionale Programmierung (Funktionen auf Objekte anwenden) tibble Erweiterung von data.frame stringr Funktionen f√ºr Strings, d.h. Textvariablen forcats Funktionen f√ºr factor Jedes dieser Pakete hat ein Cheat Sheet, eine √ºbersichtliche Zusammenstellung der Funktionen des Pakets. Sie bekommen die Cheet Sheats √ºber die tidyverse-Seite (https://www.tidyverse.org/packages/), indem Sie auf das jeweilige Paket klicken und zum Abschnitt ‚ÄòCheatsheet‚Äô scrollen. 8.2 Der Workflow 8.2.1 Daten einlesen Sie kennen bereits die sehr umfangreiche Funktion read.table() zum Einlesen der Daten. Die Funktion read_delim() ist die allgemeinste Funktion der read_* Familie aus readr in tidyverse; read_csv() und read_csv2() sind jeweils f√ºr komma- und strichpunkt-getrennte Datens√§tze gedacht. Man k√∂nnte berechtigterweise fragen, warum eine neue Funktion f√ºr etwas erfinden, was es schon gibt. Die Autoren von tidyverse versprechen Konsistenz und Geschwindigkeit. Ersteres war schon immer ein Problem von R, da es nicht von Computerspezialisten, sondern von Anwendern erfunden wurde. Daher ist eine Vereinheitlichung durch tidyverse mehr als willkommen. Und Geschwindigkeit ist sp√§testens bei gr√∂√üeren Datens√§tzen ein wichtiger Punkt. Wir sehen uns erneut Daten des Deutschen Wetterdienstes an, wie im Kapitel 5. Nur diesmal sind es Stundenwerte f√ºr relative Luftfeuchte (%) und Lufttemperatur (¬∞C). Die Daten von drei Wetterstationen, n√§mlich Hof, Frankfurt und K√∂ln-Bonn, befinden sich in der Datei Drei_Stationen.csv Beim Einlesen zeigt Ihnen read_delim() bereits, welche Spalten und welche Datentypen es erkennt, mit trim_ws = T werden Leerzeichen aus Spalten entfernt. library(tidyverse) temp_humid &lt;- read_delim(&#39;Drei_Stationen.csv&#39;, delim = &#39;;&#39;, trim_ws = T) ## Parsed with column specification: ## cols( ## STATIONS_ID = col_double(), ## MESS_DATUM = col_double(), ## QN_9 = col_double(), ## TT_TU = col_double(), ## RF_TU = col_double(), ## eor = col_character() ## ) Eine weitere Kontrolle bietet die Funktion print(), die das eingelesene Ergebnis √ºbersichtlich (und im Notebook interaktiv) darstellt. Sie m√ºssen hier nicht mehr head() verwenden, da grunds√§tzlich nur die ersten 10 Zeilen dargestellt werden. print(temp_humid) ## # A tibble: 39,600 x 6 ## STATIONS_ID MESS_DATUM QN_9 TT_TU RF_TU eor ## &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; ## 1 2261 2018111900 3 -2.8 99 eor ## 2 2261 2018111901 3 -2.5 100 eor ## 3 2261 2018111902 3 -2.3 100 eor ## 4 2261 2018111903 3 -2 100 eor ## 5 2261 2018111904 3 -1.9 99 eor ## 6 2261 2018111905 3 -2.1 99 eor ## 7 2261 2018111906 3 -1.8 99 eor ## 8 2261 2018111907 3 -1.5 99 eor ## 9 2261 2018111908 3 -1.1 99 eor ## 10 2261 2018111909 3 -0.6 97 eor ## # ‚Ä¶ with 39,590 more rows Das gleiche Ergebnis bekommen Sie auch ohne print(), wenn Sie wie gewohnt den Namen des Objekts tippen. temp_humid ## # A tibble: 39,600 x 6 ## STATIONS_ID MESS_DATUM QN_9 TT_TU RF_TU eor ## &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; ## 1 2261 2018111900 3 -2.8 99 eor ## 2 2261 2018111901 3 -2.5 100 eor ## 3 2261 2018111902 3 -2.3 100 eor ## 4 2261 2018111903 3 -2 100 eor ## 5 2261 2018111904 3 -1.9 99 eor ## 6 2261 2018111905 3 -2.1 99 eor ## 7 2261 2018111906 3 -1.8 99 eor ## 8 2261 2018111907 3 -1.5 99 eor ## 9 2261 2018111908 3 -1.1 99 eor ## 10 2261 2018111909 3 -0.6 97 eor ## # ‚Ä¶ with 39,590 more rows In diesem Datensatz sind folgende Parameter (Spalten) enthalten (s. Datensatzbeschreibung des DWDs) Parameter Beschreibung STATIONS_ID Stationsidentifikationsnummer MESS_DATUM Zeitstempel im Format yyyymmddhh QN_9 Qualit√§tsniveau der nachfolgenden Spalten TT_TU Lufttemperatur in 2m H√∂he ¬∞C RF_TU relative Feuchte % eor Ende data record class(temp_humid) ## [1] &quot;spec_tbl_df&quot; &quot;tbl_df&quot; &quot;tbl&quot; &quot;data.frame&quot; Das Objekt temp_humid ist ein sogen. Tibble, ein data.frame mit ‚Äúmodernem‚Äù Verhalten. Z.B. gibt die Funktion print() nur die ersten 10 Zeilen aus, die Datentypen in den Spalten werden in hellgrau zwischen ‚Äò&lt;&gt;‚Äô mit angegeben etc. Mehr zu Tibbles finden Sie in Kapitel 10 ‚ÄúTibbles‚Äù in R4DS. Ein weiteres Paket, dass zwar nicht zum Kern von tidyverse geh√∂rt, jedoch trotzdem extrem n√ºtzlich ist, hei√üt lubridate. Es hilft, Text in richtige Datums-Objekte zu transformieren (ohne sich die kryptischen Datumsformate von R merken zu m√ºssen). Wir transformieren die Spalte temp_humid$MESS_DATUM in ein richtiges Datum mit Uhrzeit. library(lubridate) ## ## Attaching package: &#39;lubridate&#39; ## The following objects are masked from &#39;package:base&#39;: ## ## date, intersect, setdiff, union temp_humid$MESS_DATUM &lt;- ymd_h(temp_humid$MESS_DATUM) print(temp_humid) ## # A tibble: 39,600 x 6 ## STATIONS_ID MESS_DATUM QN_9 TT_TU RF_TU eor ## &lt;dbl&gt; &lt;dttm&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; ## 1 2261 2018-11-19 00:00:00 3 -2.8 99 eor ## 2 2261 2018-11-19 01:00:00 3 -2.5 100 eor ## 3 2261 2018-11-19 02:00:00 3 -2.3 100 eor ## 4 2261 2018-11-19 03:00:00 3 -2 100 eor ## 5 2261 2018-11-19 04:00:00 3 -1.9 99 eor ## 6 2261 2018-11-19 05:00:00 3 -2.1 99 eor ## 7 2261 2018-11-19 06:00:00 3 -1.8 99 eor ## 8 2261 2018-11-19 07:00:00 3 -1.5 99 eor ## 9 2261 2018-11-19 08:00:00 3 -1.1 99 eor ## 10 2261 2018-11-19 09:00:00 3 -0.6 97 eor ## # ‚Ä¶ with 39,590 more rows 8.2.2 Daten zusammenfassen Die drei Wetterstationen haben folgende IDs: station_ids &lt;- tibble(&#39;Hof&#39; = &#39;2261&#39;, &#39;Frankfurt&#39; = &#39;1420&#39;, &#39;Koeln&#39; = &#39;2667&#39;) Ich m√∂chte wissen, wie viele Messpunkte es pro Station gibt: temp_humid %&gt;% count() ## # A tibble: 1 x 1 ## n ## &lt;int&gt; ## 1 39600 Die Zeichenkombination %&gt;% hei√üt Pipe-Operator (pipe) und wird als ‚Äòund dann‚Äô gelesen (then). Der Ausdruck temp_humid %&gt;% count() hei√üt also: nimm temp_humid und dann z√§hle die Eintr√§ge. Der Pipe-Operator ist die Kernphilosophie von tidyverse und wird Ihnen √ºberall begegnen. Der Operator stammt aus dem Paket magrittr (https://magrittr.tidyverse.org/). Seine Hauptaufgabe ist es, den Code √ºbersichtlicher und besser lesbar zu machen (vielleicht nicht gleich zu Beginn der Lernkurve aber schon sehr bald üòÑ). Die Funktion count() geh√∂rt zum Paket dplyr, das f√ºr Datentransformationen zust√§ndig ist. Dieses Paket enth√§lt 5 Grundfunktionen (alle nach Verben benannt üòÑ): Funktion Bedeutung filter() W√§hle Daten anhand ihrere Werte arrange() Sortiere Zeilen select() W√§hle Variablen anhand ihrere Namen mutate() Erstelle neue Variablen als Funktionen vorhandener Variablen summarize() Fasse Daten zusammen Ich m√∂chte nun wissen, wie viele Messpunkte es f√ºr K√∂ln-Bonn gibt. tidyverse ist konsistent: jeder Aufruf einer Funktion aus dplyr gibt ein tiblle zur√ºck (und nicht mal data.frame mal Vektor). temp_humid %&gt;% filter(STATIONS_ID == station_ids$Koeln) %&gt;% count() ## # A tibble: 1 x 1 ## n ## &lt;int&gt; ## 1 13200 8.2.3 Daten plotten Wir w√§hlen nur die Station K√∂ln-Bonn und plotten die Stundenwerte der Temperatur mit dem Paket ggplot2. # K√∂ln-Bonn w√§hlen koeln &lt;- temp_humid %&gt;% filter(STATIONS_ID == station_ids$Koeln) koeln ## # A tibble: 13,200 x 6 ## STATIONS_ID MESS_DATUM QN_9 TT_TU RF_TU eor ## &lt;dbl&gt; &lt;dttm&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; ## 1 2667 2018-11-19 00:00:00 3 -2.9 69 eor ## 2 2667 2018-11-19 01:00:00 3 -1.7 78 eor ## 3 2667 2018-11-19 02:00:00 3 -2.4 82 eor ## 4 2667 2018-11-19 03:00:00 3 0.2 89 eor ## 5 2667 2018-11-19 04:00:00 3 1.7 84 eor ## 6 2667 2018-11-19 05:00:00 3 0.3 90 eor ## 7 2667 2018-11-19 06:00:00 3 3.4 84 eor ## 8 2667 2018-11-19 07:00:00 3 4.1 81 eor ## 9 2667 2018-11-19 08:00:00 3 3.9 80 eor ## 10 2667 2018-11-19 09:00:00 3 4.8 78 eor ## # ‚Ä¶ with 13,190 more rows # Plotten ggplot(data = koeln, aes(x = MESS_DATUM, y = TT_TU)) + geom_line() Sie werden sehr bald schon das Paket ggplot2 nicht mehr missen wollen. Es erstellt mit wenig Aufwand sehr ansehnliche Grafiken. Nat√ºrlich m√ºssen Sie, wie in Base-R auch, f√ºr professionelle Grafiken nacharbeiten. ggplot2 folgt einer sogen. Grafikgrammatik (grammer of graphics), indem es seine Grafiken mit ‚Äò+‚Äô aufbaut. Erst sagt man in der Funktion ggplot() welchen Datensatz man plotten m√∂chte, was auf die x- und y-Achse kommt und ob man z.B. Farbe f√ºr Gruppen in Daten m√∂chte. All diese sichtbaren Elemente nennt man √Ñsthetiken (Parameter aes). Erst wenn diese ‚ÄòFormalien‚Äô gekl√§rt sind, sagt man, welche Form der Darstellung man m√∂chte. Im oberen Beispiel ist es ein Linienplot. Alle Darstellungsarten in ggplot2 beginnen mit geom_*() und sind daher konsistent benannt. Die Informationen zu Daten, x-, y-Achse etc. werden an die geom_*()-Funktionen von der Mutterfunktion ggplot() weiter vererbt. Daher sind die Klammern in geom_line() leer. Wir wollen nun die Monatsmittelwerte f√ºr die Temperatur berechnen und diese darstellen. Als erstes erstellen wir zwei neue Spalten, die jeweils das Jahr und den Monat beinhalten. Die beiden neuen Spalten werden am Ende von temp_humid angeh√§ngt. temp_humid &lt;- mutate(temp_humid, year = year(temp_humid$MESS_DATUM), month = month(temp_humid$MESS_DATUM)) temp_humid ## # A tibble: 39,600 x 8 ## STATIONS_ID MESS_DATUM QN_9 TT_TU RF_TU eor year month ## &lt;dbl&gt; &lt;dttm&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 2261 2018-11-19 00:00:00 3 -2.8 99 eor 2018 11 ## 2 2261 2018-11-19 01:00:00 3 -2.5 100 eor 2018 11 ## 3 2261 2018-11-19 02:00:00 3 -2.3 100 eor 2018 11 ## 4 2261 2018-11-19 03:00:00 3 -2 100 eor 2018 11 ## 5 2261 2018-11-19 04:00:00 3 -1.9 99 eor 2018 11 ## 6 2261 2018-11-19 05:00:00 3 -2.1 99 eor 2018 11 ## 7 2261 2018-11-19 06:00:00 3 -1.8 99 eor 2018 11 ## 8 2261 2018-11-19 07:00:00 3 -1.5 99 eor 2018 11 ## 9 2261 2018-11-19 08:00:00 3 -1.1 99 eor 2018 11 ## 10 2261 2018-11-19 09:00:00 3 -0.6 97 eor 2018 11 ## # ‚Ä¶ with 39,590 more rows Jetzt k√∂nnen wir einen neuen Datensatz mit den Mittelwerten erstellen. Daf√ºr gruppieren wir erst einmal die Daten nach STATIONS_ID, year und month. Die Mittelwerte sollen ja je Station, Jahr und Monat berechnet werden. by_month &lt;- group_by(temp_humid, STATIONS_ID, year, month) monthly_means &lt;- summarize(by_month, mean_T = mean(TT_TU), mean_RH = mean(RF_TU)) ## `summarise()` regrouping output by &#39;STATIONS_ID&#39;, &#39;year&#39; (override with `.groups` argument) monthly_means ## # A tibble: 57 x 5 ## # Groups: STATIONS_ID, year [9] ## STATIONS_ID year month mean_T mean_RH ## &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 1420 2018 11 4.00 79.7 ## 2 1420 2018 12 4.73 83.7 ## 3 1420 2019 1 2.12 79.3 ## 4 1420 2019 2 4.48 74.1 ## 5 1420 2019 3 8.28 68.5 ## 6 1420 2019 4 11.7 61.0 ## 7 1420 2019 5 12.7 67.5 ## 8 1420 2019 6 21.4 60.6 ## 9 1420 2019 7 21.6 55.6 ## 10 1420 2019 8 20.7 65.6 ## # ‚Ä¶ with 47 more rows Die Struktur von monthly_means zeigt uns, dass es sich um gruppierte Daten handelt. str(monthly_means) ## tibble [57 √ó 5] (S3: grouped_df/tbl_df/tbl/data.frame) ## $ STATIONS_ID: num [1:57] 1420 1420 1420 1420 1420 1420 1420 1420 1420 1420 ... ## $ year : num [1:57] 2018 2018 2019 2019 2019 ... ## $ month : num [1:57] 11 12 1 2 3 4 5 6 7 8 ... ## $ mean_T : num [1:57] 4 4.73 2.12 4.48 8.28 ... ## $ mean_RH : num [1:57] 79.7 83.7 79.3 74.1 68.5 ... ## - attr(*, &quot;groups&quot;)= tibble [9 √ó 3] (S3: tbl_df/tbl/data.frame) ## ..$ STATIONS_ID: num [1:9] 1420 1420 1420 2261 2261 ... ## ..$ year : num [1:9] 2018 2019 2020 2018 2019 ... ## ..$ .rows : list&lt;int&gt; [1:9] ## .. ..$ : int [1:2] 1 2 ## .. ..$ : int [1:12] 3 4 5 6 7 8 9 10 11 12 ... ## .. ..$ : int [1:5] 15 16 17 18 19 ## .. ..$ : int [1:2] 20 21 ## .. ..$ : int [1:12] 22 23 24 25 26 27 28 29 30 31 ... ## .. ..$ : int [1:5] 34 35 36 37 38 ## .. ..$ : int [1:2] 39 40 ## .. ..$ : int [1:12] 41 42 43 44 45 46 47 48 49 50 ... ## .. ..$ : int [1:5] 53 54 55 56 57 ## .. ..@ ptype: int(0) ## ..- attr(*, &quot;.drop&quot;)= logi TRUE Da wir aber mit den Daten weiter rechnen wollen, ist es besser, die Gruppierung wieder aufzugeben. Es k√∂nnte sonst sp√§ter Fehlermeldungen geben. monthly_means &lt;- ungroup(monthly_means) Um die Daten als Zeitreihen zu plotten, erstellen wir noch eine ordentliche Zeit-Spalte. Die Funktion parse_date_time() kann aus Character richtige Datums-Zeitobjekte erstellen. Sie ist allgemeienr als die oben verwendete ymd() Funktion, da man hier das Format explizit angeben kann. In unserem Fall ist das Format ‚Äòym‚Äô f√ºr Jahr und Monat. monthly_means &lt;- monthly_means %&gt;% mutate(my_date = parse_date_time(paste0(monthly_means$year, monthly_means$month), &#39;ym&#39;, tz = &#39;CET&#39;)) ggplot(data = monthly_means, aes(x = my_date, y = mean_T, col = factor(STATIONS_ID))) + geom_line() + labs(x = &#39;Time&#39;, y = &#39;Temperature (¬∞C)&#39;, color = &#39;Station&#39;) Wir werden in eine sp√§tere Kapitel auf ggplot2 genauer eingehen. F√ºrs Erste soll es als Appetithappen reichen üç∞. 8.3 Weiterf√ºhrende Literatur und Videos R4DS: Kapitel 5 ‚ÄúData transformation‚Äù, 11 ‚ÄúData import‚Äù Eine live Analyse des Hauptautors von tidyverse, Hadley Wickham. Empfehlenswert, auch wenn er viel zu schnell tippt üòÑ. 8.4 Inhalt der live Einf√ºhrung Verschiedene Funktionen aus tydiverse anhand der Aufgaben 9.6.1 und 9.6.2 "],
["aufgabensammlung.html", "Kapitel 9 Aufgabensammlung 9.1 Erste Schritte 9.2 Daten in R 9.3 Daten visualisieren, Teil I: Fokus auf R 9.4 Reproduzierbare Berichte mit R Markdown 9.5 Eigene Funktionen schreiben 9.6 Tidyverse 9.7 Daten visualisieren, Teil II: Fokus auf Daten 9.8 Tidy data", " Kapitel 9 Aufgabensammlung 9.1 Erste Schritte 9.1.1 Ars Haushaltsbuch Der angehende Datenanalyst Ar Stat m√∂chte dem Rat seiner Mutter folgen und ein Haushaltsbuch anlegen. Als erstes m√∂chte er sich einen √úberblick √ºber seine Ausgaben in der Uni-Mensa verschaffen und erstellt die folgende Tabelle: Tabelle 9.1: Ars Mensaausgaben Wochentag Ausgaben Montag 2,57 Dienstag 2,90 Mittwoch 2,73 Donnerstag 3,23 Freitag 3,90 Wie viel hat Ar insgesamt in der Woche ausgegeben? Wie viel hat er im Schnitt pro Tag ausgegeben? Wie stark schwanken seine Ausgaben? Leider hat Ar sich beim √ºbertragen der Daten vertippt. Er hat am Dienstag seine Freundin zum Essen eingeladen und 7,95 ‚Ç¨ statt 2,90 ‚Ç¨ ausgegeben. Korrigieren Sie Ars Fehler. Wie ver√§ndern sich die Ergebnisse aus den Teilaufgaben 1 bis 3 Warum? 9.2 Daten in R 9.2.1 Bestandesaufnahme im Wald Ar Stat arbeitet als HiWi in der AG √ñkosystemforschung und soll im Nationalpark Eifel eine Bestandsaufnahme durchf√ºhren (d.h. Baumh√∂hen und -durchmesser vermessen). Er notiert den BHD (Brusth√∂hendurchmesser) und die Art der B√§ume. Lesen Sie den Datensatz BHD.txt ein und ordnen Sie ihn der Variable BHD zu. Erstellen Sie einen Vektor a mit Baumnummern. Von welcher Art sind die Elemente des Vektors a? F√ºgen Sie die Datens√§tze BHD und a zu einem data.frame zusammen und benennen Sie die Spalten sinnvoll. L√∂schen Sie den Vektor a. Lesen Sie den Datensatz Art.txt ein und ordnen Sie ihn der Variablen art zu. F√ºgen Sie die Art in den data.frame ein. Erstellen Sie eine Tabelle mit der Anzahl der jeweiligen Arten. Nutzen Sie die Funktion table. Speichern Sie die Tabelle mit write.table. 9.3 Daten visualisieren, Teil I: Fokus auf R 9.3.1 Wahlbeteiligung bei der Bundestagswahl 2017 Bauen Sie die Grafiken aus der Einf√ºhrung nach (Abbildung 9.1). Abbildung 9.1: Wahlbeteiligung bei den Bundestagswahlen. Quelle: Der Bundeswahlleiter. Lesen Sie den Datensatz Wahlbeteiligung.csv in R ein und ordnen Sie ihn dem Objekt bet zu. Der Datensatz hat einen header und haben einen Strichpunkt als Spaltentrenner. Sehen Sie sich die Struktur und die ersten und letzten 6 Zeilen des Datensatzes an. Stellen Sie die Wahlbeteiligung als Funktion der Zeit in einem Streudiagramm dar. W√§hlen Sie die passende Darstellungsform type. Beschriften Sie die Grafik. Speichern Sie die Grafik als pdf ab. 9.3.2 Zweitstimme bei der Bundestagswahl 2017 Bauen Sie die Grafiken aus der Einf√ºhrung nach (Abbildung 9.2). Abbildung 9.2: Zweitstimme bei der Bundestagswahl 2017. Quelle: Der Bundeswahlleiter. Lesen Sie den Datensatz Zweitstimme.csv in R ein und ordnen Sie ihn dem Objekt zweit zu. Der Datensatz hat einen header und haben einen Strichpunkt als Spaltentrenner. Sehen Sie sich die Struktur und die ersten und letzten 6 Zeilen des Datensatzes an. Stellen Sie die die Zweitstimmen pro Partei in einem S√§ulendiagramm dar. Sortieren Sie die Zweitstimmen in absteigender Reihenfolge. Beschriften Sie die Grafik. Speichern Sie die Grafik als pdf ab. 9.3.3 Ergebnisse der Bundestagswahl in einer Grafik Stellen Sie beide Grafiken nebeneinander dar wie in Abbildung (9.3) gezeigt. Abbildung 9.3: Ergebnisse der Bundestagswahl 2017. Quelle: Der Bundeswahlleiter. 9.3.4 Einen zu gro√üen wei√üen Rand vermeiden Bei Berichten haben Abbildungen meistens keine √úberschrift, da alles in der Bildunterschrift erkl√§rt wird. Wenn man die √úberschrift beim plotten wegl√§sst, die Standardeinstellungen f√ºr die R√§nder aber beibeh√§lt, entsteht ein zu gro√üer wei√üer Rand um die Grafik. Diesen wollen wir nun abschalten. Kopieren Sie den Code zum Plotten der Temperaturen aus dem Kapitel 5. Stellen Sie oben und rechts einen Rand von 0.1 Zeilen ein. Speichern Sie die Grafik als pdf ab. 9.3.5 Spielen mit der Funktion par Setzen Sie die √úbung 9.3.4 fort. Denken Sie an den richtigen Aufruf mit der Zuweisung von op &lt;- par( ... )! Probieren Sie die Gr√∂√üeneinstellung cex = 2 in plot aus. Testen Sie unterschiedliche Werte. Probieren Sie die Einstellungen cex.axis, cex.lab und cex.main in par aus. Probieren Sie die Einstellung col in plot aus. Probieren Sie die Einstellungen col.axis, col.lab und col.main aus. Probieren Sie die Schrifteinstellungen aus. Dazu stellen Sie den Parameter family in par auf ‚Äúserif‚Äù, ‚Äúsans‚Äù oder ‚Äúmono‚Äù. Probieren Sie die Parameter font.lab = 2 und font.axis = 2 direkt in plot aus. Zahlen 1 bis 5 stehen jeweils f√ºr normal, fett, kursiv, fett-kursiv und symbolisch. 9.4 Reproduzierbare Berichte mit R Markdown 9.4.1 Erster eigener Bericht Erstellen Sie ein R Notebook aus den Notizen der ersten 3 R-Sessions. 9.5 Eigene Funktionen schreiben 9.5.1 R-Hausaufgaben An dem Kurs ‚ÄúEinf√ºhrung in R‚Äù nehmen 49 Studierende teil. Der Leistungsnachweis besteht aus Hausaufgaben, die insgesamt mit 100 Punkten bewertet werden. Ab 50 Punkten gilt der Kurs als bestanden. Lesen Sie den Datensatz R-HAs.txt, der die Endpunkte enth√§lt, ein. Ermitteln Sie, wie viele Teilnehmer bestanden und wie viele nicht bestanden haben. 9.5.2 Flederm√§use, die Zweite Wir besch√§ftigen uns erneut mit den Flederm√§usen. Lesen Sie den korrigierten(!) Datensatz Fledermaus_cor.txt ein. Schreiben Sie eine Funktion, die den Entwicklungsstand der Tiere klassifiziert. Nutzen Sie dazu die ad hoc Regel: Individuum &lt; 5 cm ist ein Jungtier, sonst erwachsen. Erstellen Sie eine ordinal-skalierte Variable alter mit dem Entwicklungsstand der Tiere. Wie viele Erwachsene und wie viele Jungtiere wurden vermessen? 9.6 Tidyverse 9.6.1 Fledermaus, die Dritte Wiederholen Sie die Aufgabe 9.5.2 mit tidyverse Berechnen Sie die Mittelwerte der Gr√∂√üe f√ºr weibliche und m√§nnliche Individuen. Berechnen Sie die Mittelwerte der Gr√∂√üe f√ºr die Kategorien weiblich, m√§nnlich, Jungtier und erwachsen getrennt. 9.6.2 Unfaire Klausur? Ar belegt im 4. Semester die Veranstaltung ‚ÄúSpa√ü mit R‚Äù. Bei der Klausur gibt es 2 Aufgabengruppen mit jeweils 60 Punkten. Aufgabengruppe 1 wird an Studierende auf ungeraden Sitzpl√§tzen und Aufgabengruppe 2 an Studierende auf geraden Sitzpl√§tzen ausgegeben. Lesen Sie den Datensatz Klausurpunkte.txt ein. √úberpr√ºfen Sie Ars Vermutung, dass die Aufgabengruppe 1 im Schnitt leichter war als Aufgabengruppe 2 (d.h. in der Gruppe 1 im Schnitt mehr Punkte erzielt wurden). Berechnen Sie erst die Mittelwerte pro Gruppe. Testen Sie dann mit einem Permutationstest, ob die Mittelwerte signifikant verschieden sind. Adaptieren Sie den Code aus dem Tutorial Hypothesentests_1.Rmd. 9.7 Daten visualisieren, Teil II: Fokus auf Daten 9.7.1 Zeitreihen aus der Langen Bramke (Harz) Im Harz wurden √ºber eine l√§ngere Zeit Niederschlag, Abfluss und Temperatur gemessen. Laden Sie den Datensatz Data.dat. Stellen Sie die Temperatur in einem Streudiagramm dar. Welche Darstellungsart (Argument type in plot) erscheint Ihnen am sinnvollsten? Beschriften Sie die Graphik und f√ºgen Sie einen Titel hinzu. Speichern Sie die Graphik als pdf ab. Stellen Sie die Niederschl√§ge in einem Diagramm dar. W√§hlen Sie einen geeigneten Darstellungstyp mit type (Tipp: geben Sie f√ºr die Hilfe ?plot in die Konsole ein). 9.7.2 Temperatur-Datensatz Die Datei Temperatur.csv aus Zuur, Ieno, and Meesters (2009) enth√§lt Messungen von Temperatur, Salinit√§t und Chlorophyl a an 31 Orten entlang der d√§nischen K√ºste. Die Daten stammen vom d√§nischen Institut RIKZ (Monitoringprogramm MWTL: Monitoring Waterstaatkundige Toestand des Lands). Die Messungen wurden zwischen 1990 und 2005 durchgef√ºhrt mit einer H√§ufigkeit von 0-4 mal pro Monat je nach Jahreszeit. Lesen Sie den Temperatur-Datensatz Temperatur.csv ein. Berechnen Sie die Anzahl der Messwerte, Monatsmittelwerte f√ºr alle Stationen, sowie die Standardabweichungen. Stellen Sie die Monatsmittel der Temperatur als Linien dar. Beschriften Sie die Grafik sinnvoll. F√ºgen Sie die Standardabweichungen als Band hinzu. Speichern Sie die Grafik als pdf ab. 9.7.3 Temperatur-Datensatz, revisited Berechnen Sie die Monatsmittelwerte und Standardabweichungen je Station. Tipp: group_by(Station, Month). Stellen Sie die Daten mit einem Fehlerband dar und speichern Sie sie ab. Stellen Sie die Daten als Punkte mit Fehlerbalken dar und speichern Sie sie ab. Zur Orientierung, das Ergebnis sollte so aussehen wie in Abbildung (9.4). Abbildung 9.4: Mittelwerte der Temperatur je Station (Zuur, Ieno, and Meesters 2009) 9.7.4 Artenvielfalt in Grasl√§ndern Sie erhalten Daten aus dem Grasland-Monitoring im Yellowstone Nationalpark und dem National Bison Range (USA). Das Ziel des Monitorings ist die Untersuchung m√∂glicher √Ñnderungen der Biodiversit√§t und des Zusammenhang mit Umweltfaktoren. Biodiversit√§t wurde durch die Anzahl unterschiedlicher Arten quantifiziert. Insgesamt haben die Forscher ca. 90 Arten in 8 Transekten kartiert. Die Aufnahmen wurden alle 4 bis 10 Jahre wiederholt. Insgesamt liegen 58 Beobachtungen vor. Die Daten sind in der Datei Vegetation2.xls gespeichert. Laden Sie den Datensatz in R und sehen Sie sich das Ergebnis genau mit str, head und tail an. Diese Aufgabe dient dazu, das Einlesen von Excel-Dateien mit tidyverse zu erarbeiten. Tipp: nutzen Sie die Funktion read_xls() in der Bibliothek readxl. Lesen Sie genau in der Hilfe nach, wie Sie ein bestimmtes Tabellenblatt einlesen k√∂nnen. Kurze explorative Analyse: Berechnen Sie die Anzahl der Messungen, den Mittelwert und die Standardabweichung der Artenzahl (Variable R) pro Transekt. Plotten Sie die Artenzahl gegen die Variable BARESOIL (Anteil von unbewachsenem Boden). F√§rben Sie die Punkte je nach Transekt unterschiedlich ein. Tipp: Transekt als as.factor() konvertieren. F√ºgen Sie eine gl√§ttende Linie ohne Konfidenzband hinzu, die alle Punkte unabh√§ngig vom Transekt ber√ºcksichtigt (Abschnitt 5.2 in ggplot2 Buch). Beschriften Sie die Graphik (auch die Legende!) sinnvoll und speichern Sie sie als pdf ab. Stellen Sie die Artenzahl je Transekt als Zeitreihe dar. Die Symbole sollen sowohl Punkte als auch Linien sein. Skalieren Sie die Gr√∂√üe der Punkte je nach Anteil des unbewachsenen Bodens (Abschnitt 6.2 im ggplot2 Buch). Beschriften Sie die Grafik (auch die Legenden!) sinnvoll und speichern Sie sie als pdf ab. Setzen Sie nun beide Grafiken neben einander, platzieren Sie die Legenden (ja nach gew√§hltem Layout) sinnvoll und speichern Sie die Grafiken ab. 9.7.5 Tracerversuche Im Waldstein wurden Tracerversuche mit dem Farbstoff Brilliant Blue durchgef√ºhrt und die gef√§rbten Bodenprofile bin√§risiert (d.h. in ein schwarz-wei√ü Bild umgewandelt). Schwarze Pixels stellen gef√§rbten Boden und wei√üe ungef√§rbten dar. Aus diesen Bin√§rbildern wurde anschlie√üend eine Reihe von Kenngr√∂√üen berechnet. Lesen Sie die Datei Waldstein2005_ind.txt ein. Die Tiefe eines Profils ist 579 Pixel und es liegen 6 Profile untereinander in der Spalte d. Berechnen Sie die 5%, 50% und 95% Quantile des F√§rbeanteils (Index d) der 6 Profile. Stellen Sie den Median des Anteils der F√§rbung mit der Tiefe dar und f√ºgen Sie die Quantile als transparente Fl√§che hinzu (Tipp: polygon). 9.8 Tidy data 9.8.1 Wasserentnahme mit Datenquelle Excel Wir besch√§ftigen uns mit dem Einlesen und bereinigen von Daten aus Exceldateien. Dazu nutzen wir das Beispiel aus einer der ersten Sitzungen zur Wasserentnahme in der EU. Sehen Sie sich die Struktur der Datei TEN000021586860138332.xlsx an und lesen Sie sie ein. Nutzen Sie dazu die Funktion read_xlsx() aus dem Paket readxl. Bereinigen Sie den Datensatz und konvertieren Sie ihn in tidy. Nutzen Sie dazu die Funktion pivot_longer(). Finden und korrigieren Sie den Fehlwert. Filtern Sie die Eintr√§ge f√ºr die EU heraus und behalten Sie nur die einzelnen L√§nder bei. Stellen Sie die √Ñnderung der Wasserentnahme pro Land dar. 9.8.2 Wasserentnahme mit Datenquelle EUROSTAT direkt Wir k√∂nnen die Datenbank EUROSTAT direkt √ºber ihr API (Application Programming Interface) ansprechen. Leider ist das herunter geladene Datenformat sehr umst√§ndlich. Um uns Programmierarbeit zu sparen, nutzen wir das Paket eurostat, das die Daten aus der Datenbank herunterl√§dt und gleich ordentlich formatiert. Installieren Sie das Paket eurostat und sehen Sie sich das Tutorial f√ºr das Paket an (https://ropengov.github.io/eurostat/articles/website/eurostat_tutorial.html) Durchsuchen Sie die Datenbank nach allen Datens√§tzen, die das Wort ‚Äúwater‚Äù enthalten und darin das Wort ‚Äúabstraction‚Äù. Laden Sie den entsprechenden Datensatz herunter (env_wat_abs). Das Paket skimr bietet Zusammenfassungsfunktionen f√ºr Datens√§tze, die man auch in der Pipe benutzen kann. Installieren Sie das Paket und wenden Sie die Funktion skim() auf den heruntergeladenen Datensatz an. Welche Wasserquellen und Nutzer sind im Datensatz enthalten (https://appsso.eurostat.ec.europa.eu/nui/show.do?dataset=env_wat_abs&amp;lang=en)? Stellen Sie die Wasserentnahme pro Einwohner dar (Gesamtentnahme aus allen Quellen: wat_proc == ‚ÄòABST‚Äô &amp; wat_src == ‚ÄòFRW‚Äô). Berechnen Sie die Gesamtmenge des entnommenen Wassers f√ºr alle L√§nder je Quelle (Fresh surface water und Fresh ground water). Stellen Sie diese Daten als Punktdiagramm, als Balkendiagramm und als Fl√§chendiagramm dar. Was ist das Problem mit dem Fl√§chendiagramm? "],
["literatur.html", "Literatur", " Literatur Ihaka, Ross, and Robert Gentleman. 1996. ‚ÄúR: A Language for Data Analysis and Graphics.‚Äù Journal of Computational and Graphical Statistics 5 (3): 299‚Äì314. https://doi.org/10.1080/10618600.1996.10474713. Knuth, D. E. 1984. ‚ÄúLiterate Programming.‚Äù The Computer Journal 27 (2): 97‚Äì111. https://doi.org/10.1093/comjnl/27.2.97. Ligges, Uwe. 2008. Programmieren mit R. Berlin, Heidelberg: Springer Berlin Heidelberg. https://doi.org/10.1007/978-3-540-79998-6. Murrell, Paul. 2006. R Graphics. Computer Science and Data Analysis Series. Boca Raton, Fla.: Chapman &amp; Hall/CRC. Peng, Roger D. 2019. Report Writing for Data Science in R. Wickham, Hadley, and Garrett Grolemund. 2017. R for Data Science. Xie, Yihui. 2016. Bookdown: Authoring Books and Technical Documents with R Markdown. Boca Raton, Florida: Chapman; Hall/CRC. https://github.com/rstudio/bookdown. Xie, Yihui, J. J. Allaire, and Garrett Grolemund. 2018. R Markdown: The Definitive Guide. Boca Raton, Florida: Chapman; Hall/CRC. https://bookdown.org/yihui/rmarkdown. Zuur, A. F., E. Ieno, and E. Meesters. 2009. A Beginner‚Äôs Guide to R. Springer. "]
]
