--- 
title: "Datenanalyse mit R"
subtitle: "SoSe 2020"
author: "Christina Bogner"
date: "Version vom `r format(Sys.time(), '%d. %B %Y')`"
site: bookdown::bookdown_site
output: 
  bookdown::gitbook:
    config:
      toolbar:
        position: fixed
      edit : null
      download: null
      search: yes
      sharing: no
documentclass: book
bibliography: [book.bib, packages.bib]
biblio-style: apalike
link-citations: true
github-repo: https://github.com/ChrisBogner/datenanalyse.git
description: "Begleitskript zur Veranstaltung Datenanalyse mit R"
---
```{r include=FALSE, cache=FALSE}
# Load libraries
library(fontawesome)
library(kableExtra)
library(tidyverse)

knitr::knit_hooks$set(document = function(x) {
  sub('\\usepackage{graphicx, color}',
      '\\usepackage{graphicx,xcolor}', x, fixed = TRUE)
}) 



# These are different helper functions for the book

colorize <- function(x, color) {
  if (knitr::is_latex_output()) {
    sprintf("\\textcolor{%s}{%s}", color, x)
  } else if (knitr::is_html_output()) {
    sprintf("<span style='color: %s;'>%s</span>", color, 
            x)
  } else x
}

file.name <- function(x) {
  if (knitr::is_latex_output()) {
    sprintf("\\texttt{%s}", x)
  } else if (knitr::is_html_output()) {
    sprintf("<span style='font-family: sans-serif; font-size: medium'>%s</span>",
            x)
  } else x
}
```

# Vorwort

> "And honey, we're gonna do it in style"

`r tufte::quote_footer('--- Fools Garden')`

## Organisatorisches

```{block, type='rmdinfo'}
Die Coronaviruspandemie verändert unser Leben und unser Lernen. Die UzK bittet Lehrende, zumindest zu Beginn des SoSe 2020 auf digitale Lernformen umzusteigen. Daher wird dieser Kurs als ein Onlinekurs beginnen. Abhängig von der (sehr dynamischen) Lage werden wir im weiteren Kursverlauf das Format anpassen. Bitte seien Sie nachsichtig, wenn nicht alles so klappt, wie in Präsenzveranstaltungen. Wir müssen aktuell alle sehr viel dazu lernen in Sachen digitale Lehre. Sie können sicher sein, dass das Geographische Institut bemüht ist, die Lehre so effizient wie möglich weiter laufen zu lassen, damit Sie in Ihrem Studium fortfahren können.
```

In dieser Veranstaltung werden wir folgende Werkzeuge verwenden:

1. **ILIAS**: die Online-Lernplattform der UzK. Entweder sind Sie bereits automatisch in dem Kurs registriert oder werden von mir per Hand angemeldet. 
2. **Campuswire**: die Live-Chatplattform dient der allgemeinen Kommunikation und der Selbstorganisation des Lernens. Verwenden Sie diese, um Fragen mit Ihren Kommilitonen und mir zu diskutieren. Sie sollten eine Einladungsmail zu Campuswire erhalten haben.
3. **Zoom**: die Videokonferenz-Software werden wir für live Einführungen nutzen. Die Anmeldemodalitäten sind auf den Kursseiten in ILIAS erklärt.


## Sinn und Unsinn dieses Skripts
Dieses Skript ist ein lebendiges Begleitdokument des Kurses. Es wird laufend angepasst und aktualisiert.

Ich nutze verschiedene Farbkästen, um wichtige Stellen hervorzuheben:

```{block, type='rmdinfo'}
Infoblock
```

<br>

```{block, type='rmdalert'}
Achtung, wichtig!
```

<br>

```{block, type='rmdexample'}
Beispielblock
```

<br>

```{block, type='rmdoutcomes'}
Lernziele
```

<br>

```{block, type='rmdsummary'}
Zusammenfassung
```


<!--chapter:end:index.Rmd-->

```{r include=FALSE, cache=FALSE}
# Load libraries
library(fontawesome)
library(kableExtra)
library(tidyverse)

knitr::knit_hooks$set(document = function(x) {
  sub('\\usepackage{graphicx, color}',
      '\\usepackage{graphicx,xcolor}', x, fixed = TRUE)
}) 



# These are different helper functions for the book

colorize <- function(x, color) {
  if (knitr::is_latex_output()) {
    sprintf("\\textcolor{%s}{%s}", color, x)
  } else if (knitr::is_html_output()) {
    sprintf("<span style='color: %s;'>%s</span>", color, 
            x)
  } else x
}

file.name <- function(x) {
  if (knitr::is_latex_output()) {
    sprintf("\\texttt{%s}", x)
  } else if (knitr::is_html_output()) {
    sprintf("<span style='font-family: sans-serif; font-size: medium'>%s</span>",
            x)
  } else x
}
```
# Der Kurs {#einfuehrung}
## Zuordnung zum Modul und Leistungsnachweis

Dieser Kurs gehört zum Modul *Fachmethodik I* oder *Fachmethodik II* und ist aus 4 SWS Praktikum und 2 SWS Seminar aufgebaut. Das wichtigste Ziel besteht darin, Ihnen einen sicheren Umgang mit `R` beizubringen.

Den Leistungsnachweis bildet ein benoteter Praktikumsbericht.



## Lernziele des Kurses

```{block, type='rmdoutcomes'}
- Daten für Analysen vorbereiten
- eigene wiederverwendbare Skripte schreiben
- eigene Funktionen schreiben
- einfache Datenanalysen durchführen
- Daten visualisieren
- Ergebnisse reproduzierbar im Praktikumsbericht darstellen
```

## Was mir im Umgang miteinander wichtig ist

- Pünktlichkeit bei live und Präsenzsitzungen
- Gute Vorbereitung durch erledigen der blenden learning Einheiten und Hausaufgaben
- Respektieren anderer Meinungen
- Offenheit gegenüber neuen Sichtweisen, Themen und Methoden
- Geduld mit sich selbst und den anderen `r emo::ji('smile')`


<!--chapter:end:01-einfuehrung.Rmd-->

```{r include=FALSE, cache=FALSE}
# Load libraries
library(fontawesome)
library(kableExtra)
library(tidyverse)

knitr::knit_hooks$set(document = function(x) {
  sub('\\usepackage{graphicx, color}',
      '\\usepackage{graphicx,xcolor}', x, fixed = TRUE)
}) 



# These are different helper functions for the book

colorize <- function(x, color) {
  if (knitr::is_latex_output()) {
    sprintf("\\textcolor{%s}{%s}", color, x)
  } else if (knitr::is_html_output()) {
    sprintf("<span style='color: %s;'>%s</span>", color, 
            x)
  } else x
}

file.name <- function(x) {
  if (knitr::is_latex_output()) {
    sprintf("\\texttt{%s}", x)
  } else if (knitr::is_html_output()) {
    sprintf("<span style='font-family: sans-serif; font-size: medium'>%s</span>",
            x)
  } else x
}
```

# Erste Schritte in `r fa("r-project", fill = "steelblue")` {#erste_schritte}   

```{block, type = 'rmdoutcomes'}
- Layout und Bedeutung einzelner Fenster in RStudio kennen
- Anweisungen aus dem Skript an die Konsole schicken
- R als Taschenrechner benutzen
- erste Funktionen aufrufen
- Objekte mit eckigen Klammern [ ] ansprechen
- R-Hilfeseiten aufrufen
```


## Was ist R?
R ist eine Programmiersprache für Datenanalyse und statistische Modellierung. Es ist frei verfügbar (*open source software*) und neben Python einer der am meisten benutzten Programmiersprachen zur Datenanalyse und -visualisierung. R wurde von Ross Ihaka und Robert Gentleman 1996 veröffentlicht @Ihaka1996. Es gibt für R eine Vielzahl von Zusatzpaketen, die die Funktionalität und die Einsatzmöglichkeiten enorm erweitern.

Sie können R für Ihren Computer auf der offiziellen R-Seite https://www.r-project.org/ herunter laden und installieren. Auch die Pakete finden Sie dort unter CRAN (*The Comprehensive R Archive Network*). Auf den CRAN-Seiten finden Sie sogen. [CRAN Task Views](http://cran.r-project.org/web/views/), eine Übersicht über Pakete in verschiedenen Themenbereichen. Für den Umweltbereich sind folgende Paketsammlungen besonders relevant:

- Environmetrics: Analyse von Umweltdaten
- Multivariate: Multivariate Statistik
- Spatial: Analyse von räumlichen Daten
- TimeSeries: Zeitreihenanalyse

Zu Beginn des Kurses, werden wir jedoch nicht auf Ihren lokalen Rechnern arbeiten, sondern in einer Cloud (s.u.). Das ermöglicht einen schnelleren Einstieg in R und bietet eine live Unterstützung durch den Dozenten beim Programmieren. Daher biete ich zu diesem frühen Zeitpunkt im Kurs keine Unterstützung bei der Installation. Für die ganz Ungeduldigen, gibt es hier eine kurze *Einleitung zur Installation*

<iframe width="640" height="360" src="https://www.youtube.com/embed/kygOqp_zijk?list=PLG4WP9jv27SeMbBjhVcyXrGKQgnaex-0o" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>


## Was ist RStudio?
RStudio Desktop ist eine Entwicklungsumgebung für R. Sie können die *open source* Version kostenlos für Ihren Rechner [hier](https://rstudio.com/products/rstudio/#rstudio-desktop) herunterladen.

Es gibt eine live Einführung in RStudio im Kurs. Zusätzlich können Sie hier ein Video dazu ansehen.

<iframe width="640" height="360" src="https://www.youtube.com/embed/r5wOhFVWXUE?list=PLG4WP9jv27SeMbBjhVcyXrGKQgnaex-0o" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>


## RStudio Cloud
Zu Beginn des Kurses werden wir in der [RStudio Cloud](https://rstudio.cloud/) arbeiten. Sie sollten eine Einladungsmail zu unserem Kurs in der Cloud bekommen haben. Ich werde in der Cloud Projekte für Sie anlegen (*assignment*), die Skripte, Arbeitsanweisungen etc. beinhalten. Wenn Sie auf so ein Assignment klicken, wird für Sie automatische ein Kopie des Projekts erstellt, in der Sie dann arbeiten können.

Der große Vorteil der Cloud ist, dass ich direkt in Ihre Projekte eingreifen kann, wenn es mal zu Fehlern kommt. Während ich in Ihrem Projekt arbeite, werden Sie kurz aus der R-Sitzung ausgeloggt, da die Cloud kein gleichzeitiges Arbeiten unterstützt. Nehmen Sie sich etwas Zeit, um die Cloud und die darin enthaltenen [Tutorials](https://rstudio.cloud/learn/primers) kennen zu lernen.

Sowohl in der RStudio Cloud als auch in einer lokalen Installation, ist Ihr RStudio so aufgebaut wie in Abbildung \@ref(fig:rstudio).

```{r rstudio, echo = F, fig.cap = 'Aufbau von RStudio', fig.width = 6, out.width = "100%"}
knitr::include_graphics('RStudio.png')
```




## Inhalt der live Einführung

- Überblick über RStudio
- R als Taschenrechner
- einfache Funktionen aufrufen
- Zuordnungen (*assignments*)
- Notation mit eckigen Klammern [ ] (*array*-Notation)
- Hilfeseiten aufrufen

Funktionen, die wir in der Session nutzen werden:

| Funktion | Bedeutung | Beispielaufruf |
:-----------|:----------|:------------|
`pi`	|	Zahl pi	|  `pi`|
`sin` | Sinus	| `sin(2)`|
`cos` | Cosinus	| `cos(2)`|
`sqrt` | Quadratwurzel	| `sqrt(2)`|
`c`	|  (*concatenate*) Fügt Daten zu einem Vektor zusammen	| `c(1,2,3,4)`|
`help.start` | Öffnet ein Browser-Fenster mit diversen Handbüchern	| `help.start()`|
`help.search` | Sucht nach einem Begriff in Hilfe-Dateien | `help.search('time')`|
`??` | alias `help.search` | `??time`|
`help`	| Sucht nach einer Funktion | `?mean`|
`?`	| alias  `help()`	| `?mean`|
`mean`	| Mittelwert	| `mean(c(1,2,3,4))`|
`var`	| Varianz	| `var(c(1,2,3,4))`|
`sd`	| Standardabweichung	|	`sd(c(1,2,3,4))`|
`sum`	| Summe	| `sum(c(1,2,3,4))`|
`vector`	| Generiert einen Vektor	| `vector(length=3, mode='numeric')`




<!--chapter:end:02-was_ist_r.Rmd-->

```{r include=FALSE, cache=FALSE}
# Load libraries
library(fontawesome)
library(kableExtra)
library(tidyverse)

knitr::knit_hooks$set(document = function(x) {
  sub('\\usepackage{graphicx, color}',
      '\\usepackage{graphicx,xcolor}', x, fixed = TRUE)
}) 



# These are different helper functions for the book

colorize <- function(x, color) {
  if (knitr::is_latex_output()) {
    sprintf("\\textcolor{%s}{%s}", color, x)
  } else if (knitr::is_html_output()) {
    sprintf("<span style='color: %s;'>%s</span>", color, 
            x)
  } else x
}

file.name <- function(x) {
  if (knitr::is_latex_output()) {
    sprintf("\\texttt{%s}", x)
  } else if (knitr::is_html_output()) {
    sprintf("<span style='font-family: sans-serif; font-size: medium'>%s</span>",
            x)
  } else x
}
```
# Daten in R {#daten}

```{block, type = 'rmdoutcomes'}
- Daten einlesen mit `read.table`
- Datenstrukturen erstellen
- Typen von Daten in R abfragen
- Daten speichern mit `write.table`
```

## Datenstrukturen erzeugen

In R gibt es unterschiedliche Datenobjekte. Es ist wichtig, sich über die Struktur (oder Typ) des Datenobjekts Gedanken zu machen. Denn diese bestimmt, was mit einem Objekt gemacht werden kann und ob Funktionen damit richtig umgehen können. Schließlich ist es nicht egal, ob es sich bei einem Objekt um ein numerisches Objekt oder einfach Text (*character*) handelt.

Die wichtigsten Datentypen sind

- **Vektoren**: hier gruppiert man gleichartige Elemente, z.B. Zahlen. Auch eine einzelne Zahl (ein Skalar) wird von R wie ein Vektor behandelt.
- **Matrizen**: zweidimensionale (Zeilen und Spalten) Datentabellen mit gleichartigen Elementen.
- **Listen**: können beliebige Elemente beliebiger Länge enthalten.
- **Dataframes**: zweidimensionale Datentabellen, die beliebige Elemente enthalten können. Die Spalten der Dataframes müssen allerdings gleichartige Elemente enthalten. Dataframes sind eine Unterart von Listen.

Neben diesen Hauptstrukturen gibt es

- **Factor**: ein besonderer Vektor für kategorielle Variablen 

Um diese Datenstrukturen zu erzeugen, gibt es jeweils eine Funktion mit gleichlautendem Namen.

```{r}
# Vektor erzeugen
my_vect = vector(length = 3, mode = 'numeric')
my_vect
# Matrix erzeugen
my_matrix = matrix(data = c(1:(3*4)), nrow = 3, ncol = 4)
my_matrix
# Dataframe erzeugen
my_dataframe = data.frame('Spalte_1' = rep('Text', 10),
                          'Spalte_2' = 1:10)
my_dataframe
# Liste erzeugen
my_list = list('Schachtel_1' = 3, 'Schachtel_2' = my_dataframe,
               'Schachtel_3' = 'Noch mehr Text')
my_list
# Factor erzeugen
my_factor = factor(c('R', 'RStudio', 'Cloud', 'Cloud', 'R', 'R'))
my_factor
```


## Arten von Daten in R

Die Datenstrukturen `vector`, `data.frame` usw. können unterschiedliche Arten von Daten enthalten.

Name | Beispiele |
:-----------|:----------|
raw | 3A, FE |
logical | TRUE, FALSE |
integer | 1, 42, -3
numeric/double | 3, 2.81, 6.032e23 |
complex | 1.2+2.2i |
character | "foo"|


## Objekt, sag mir wer du bist

Um die Struktur und/oder Datenart abzufragen, verwendet man `class`, `typeof`, `mode` und `storage.mode`.

```{r}
class(my_vect)
typeof(my_vect)
class(my_dataframe)
typeof(my_dataframe)
```

<br> 
Mit `str` kann man das Innenleben eines Objekts anzeigen. Das ist besonders wichtig nach dem Einlesen von Daten, um das Ergebnis des Einlesens zu kontrollieren. Dabei kontrolliert man, dass z.B. alle numerischen Spalten auch als Zahlen eingelesen wurden und nichts schief gegangen ist.

```{r}
str(my_dataframe)
```


Weiter Funktionen, die Auskunft über Objekte geben sind `length`, sinnvoll auf nur Vektoren und Listen, und `dim`, sinnvoll auf zweidimensionalen Datenobjekten. Wenn Sie versuchen, `dim` auf einem Vektor aufzurufen, gibt es `NULL` (s.u.), weil Vektoren keine Dimensionen haben. Wenn Sie `length` auf einem `data.frame` aufrufen, bekommen Sie die Anzahl der Dimensionen, nämlich 2. Das sind keine besonders spannenden Informationen `r emo::ji('smile')`.

```{r}
length(my_vect)
dim(my_vect)
length(my_dataframe)
dim(my_dataframe)
```


## Datenlücken, Fehlschläge etc.

Datenlücken werden in R mit `NA` kodiert, Fehlschläge bei Berechnungen mit `NaN` (not a number) und Vektoren der Länge 0 mit `NULL`. Letzteres wird häufig beim Aufruf von Funktionen benutzt, wenn man bestimmte Parameter ausschalten möchte. Die Benutzung muss aber immer in der Hilfe zur jeweiligen Funktion nachgeschlagen werden.


## Inhalt der live Einführung

- Daten einlesen und `data.frame` erstellen: Aufgabe \@ref(bestandesaufnahme)


Funktionen, die wir in der Session nutzen werden:

| Funktion | Bedeutung | Beispielaufruf |
:-----------|:----------|:------------|
`read.table` | Liest Daten aus einer Datei ein. | `read.table(file= 'Daten.txt', header=TRUE)`|
`ls` | Zeigt den Inhalt des Workspaces. | `ls`|
`head` | Zeigt den ersten Teil eines Objekts. | `head(x)`|
`tail` | Zeigt den letzten Teil eines Objekts. | `tail(x)`|
`str` | Zeigt die Struktur (Innenleben) eines Objekts an | `str(my_dataframe)` |
`length` | Gibt die Länge eines Objekts.	| `length(x)`|
`dim` | Gibt die Dimension eines Objekts (Reihenfolge: Zeilen, Spalten) | `dim(x)`|
`seq` | Erstellt eine regelmäßige Reihe. | `seq(from=-2, to=4, by=0.1)`|
`data.frame` | Erstellt eine Datentabelle. | `data.frame(x,y,z)`|
`colnames`, `rownames` | Benennt Spalten bzw. Zeilen eines Datenobjekts. | `colnames(x)`|
`rm` | Löscht Objekte aus dem Workspace. | `rm(x)` 
`summary` | Fasst ein Objekt zusammen. | `summary(x)`|
`table` | Erstellt eine Häufigkeitstabelle. | `table(x)`|
`which` | Gibt die TRUE-Indices eines logischen Objekts. | `which(LETTERS == 'R')`|
`history` | Zeigt die Liste mit ausgeführten Befehlen der Session. | `history`|
`write.table` | Speichert Datenobjekte als Tabelle ab. | `write.table(x, file='Tabelle.txt')`|
`save.image` | Speichert den Workspace. | `save.image(file= 'RSession.Rdata')`|
`savehistory` | Speichert die History. | `savehistory(file= 'Myhistory.Rhistory')`

<!--chapter:end:03-daten.Rmd-->

```{r include=FALSE, cache=FALSE}
# Load libraries
library(fontawesome)
library(kableExtra)
library(tidyverse)

knitr::knit_hooks$set(document = function(x) {
  sub('\\usepackage{graphicx, color}',
      '\\usepackage{graphicx,xcolor}', x, fixed = TRUE)
}) 



# These are different helper functions for the book

colorize <- function(x, color) {
  if (knitr::is_latex_output()) {
    sprintf("\\textcolor{%s}{%s}", color, x)
  } else if (knitr::is_html_output()) {
    sprintf("<span style='color: %s;'>%s</span>", color, 
            x)
  } else x
}

file.name <- function(x) {
  if (knitr::is_latex_output()) {
    sprintf("\\texttt{%s}", x)
  } else if (knitr::is_html_output()) {
    sprintf("<span style='font-family: sans-serif; font-size: medium'>%s</span>",
            x)
  } else x
}
```
# Daten visualisieren I: Einfache Grafiken {#visualisieren}

```{block, type = 'rmdoutcomes'}
- Einfache Grafiken erstellen
- Grafiken beschriften und speichern
- Die Arbeitsweise der Funktion `par` beschreiben
- Die grafischen Parameter für Randgröße, Farbe, Schrift- und Symbolgröße einstellen
- Unterschiede zwischen *high-level* und *low-level* Grafikfunktionen erklären
- Grafiken mit mehreren Plots erstellen
```

## Plotten mit R-Basisfunktionen

Für Grafikverliebte und Neugierige empfehle ich die Kapitel 2 und 3 in @Murrell2006.

### *High-level* Grafikfunktion `plot` und *low-level* Grafikfunktion `lines`

Ein Streudiagramm stellt zwei numerische Variablen gegeneinander dar. Wir betrachten Klimadaten der Station Köln-Bonn, die man beim Deutschen Wetterdienst herunterladen kann (https://www.dwd.de/DE/leistungen/klimadatendeutschland/klimadatendeutschland.html).

Sie können den Code aus den Chunks leicht herauskopieren und in RStudio laufen lassen (rechts oben in den Chunks auf das Symbol *copy to clipboard* klicken).


Wir lesen die Daten ein und sehen uns deren Struktur an.
```{r}
meteo <- read.table('produkt_klima_monat_20181001_20200430_02667.txt',
header = T, sep = ';')
str(meteo)
```


Uns interessieren hier nur die Spalten MO_TT, MO_TN, MO_TX und MESS_DATUM_BEGINN. Das sind jeweils die Monatsmittel der Lufttemperatur in 2 m Höhe, Monatsmittel des Minimums der Lufttemperatur, Monatsmittel des Maximums der Lufttemperatur und der Beginn der jeweiligen Messperiode (d.h. des Kalendermonats). Um die Daten als Zeitreihen darstellen zu können, wandeln wir die Spalte MESS_DATUM_BEGINN in ein richtiges Zeitobjekt (d.h. ein Objekt der Klasse *Date*). Das geht mit der Funktion `as.Date`. Der Parameter `format` beschreibt den Aufbau des Datums im Objekt `meteo`: erst steht das Jahr mit 4 Zeichen (z.B. 2018), dann folgt der Monat mit 2 Zeichen (z.B. 01) und dann der Tag mit 2 Zeichen (z.B. 01). Näheres zu Datumsformaten finden Sie mit `?strptime`.


```{r}
my_date <- as.Date(as.character(meteo$MESS_DATUM_BEGINN), format = '%Y%m%d')
my_date
```

Es sind Daten von Oktober 2018 bis April 2020. Wir erstellen ein Streudiagramm mit der Funktion `plot`. Mit den Parametern `xlab` und `ylab` lassen sich die beiden Achsen beschriften und `main` fügt einen Titel dazu. Der Parameter `type` bestimmt die Wahl der Symbole; hier benutzen wir `type = b` für *both*, also sowohl Punkte als auch Linien.

```{r}
plot(my_date, meteo$MO_TT, type = 'b', xlab = 'Zeit', ylab = 'Temperatur [°C]', main = 'Klimadaten der DWD-Station Köln-Bonn')
```


Die Funktion `plot` ist eine sogen. *high-level* Grafikfunktion. Das bedeutet, dass sie alle Schritte des Plottens übernimmt: sie öffnet ein neues Grafikfenster (ein Device), berechnet die Größe der Plotfläche und der Ränder (s. unten), berechnet die Ausdehnung der Achsen und die beste Achseneinteilung und plottet Ihre Daten.

Daneben gibt es *low-level* Grafikfunktionen, die nur in ein bestehendes Device plotten können. Wir wollen zu unserer Grafik nun die Minimum- und die Maximumtemperatur dazu plotten.

```{r}
plot(my_date, meteo$MO_TT, type = 'b', xlab = 'Zeit', ylab = 'Temperatur [°C]', main = 'Klimadaten der DWD-Station Köln-Bonn')

# Minimumtemperatur in blau
lines(my_date, meteo$MO_TN, col = 'blue')

# Maximumtemperatur in rot
lines(my_date, meteo$MO_TX, col = 'red')
```

Dass `lines` nur eine *low-level* Grafikfunktion ist, erkennen Sie daran, dass sie nicht in der Lage ist, den Bereich auf der y-Achse zu vergrößern, um alle Daten sichtbar zu machen. Das kann nur `plot`. Daher muss der Bereich bereits in `plot` richtig festgelegt werden. Das macht der Parameter `ylim`.

```{r}
plot(my_date, meteo$MO_TT, type = 'b', xlab = 'Zeit', ylab = 'Temperatur [°C]', main = 'Klimadaten der DWD-Station Köln-Bonn', ylim = c(0, 30))

# Minimumtemperatur in rot
lines(my_date, meteo$MO_TN, col = 'blue')

# Maximumtemperatur in blau
lines(my_date, meteo$MO_TX, col = 'red')
```

Wenn in einer Grafik mehrere Elemente dargestellt werden, benötigt man eine Legende. Das erledigt die * low-level* Grafikfunktion `legend`. 

```{r}
plot(my_date, meteo$MO_TT, type = 'b', xlab = 'Zeit', ylab = 'Temperatur [°C]', main = 'Klimadaten der DWD-Station Köln-Bonn', ylim = c(0, 30))

# Minimumtemperatur in rot
lines(my_date, meteo$MO_TN, col = 'blue')

# Maximumtemperatur in blau
lines(my_date, meteo$MO_TX, col = 'red')

legend('topright', legend = c('Mittelwert', 'Minimum', 'Maximum'),
       col = c('black', 'red', 'blue'), 
       pch = c(1, NA, NA),
       lty = 1)
```

Der Parameter `lty` steht für *line type* und die 1 bedeutet durchgezogene Linie. Mit `pch` legend wir die Art des Symbols fest; hier steht die 1 für das Standardsymbol "offener Kreis". Die Funktion `legend` hat viele Möglichkeiten und es lohnt sich, in die Hilfe zu sehen `?legend`.

### Überblick über die wichtigsten *high-level* und *low-level* Grafikfunktionen

Die wichtigsten *high-level* Grafikfunktionen nach @Ligges2008, verändert:

Funktion | Beschreibung |
:-------- | :------------ |
`plot` | kontextabhängig – generische Funktion mit vielen Methoden |
`barplot` | Säulendiagramm |
`boxplot` | Boxplot |
`contour` | Höhenlinien-Plot |
`coplot` | Conditioning-Plots: Plots zweier Variablen aufgeteilt nach Werten einer dritten |
`curve` | Funktionen zeichnen |
`dotchart` | Dotplots (nach Cleveland) |
`hist` | Histogramm |
`image` |Bilder (3. Dimension als Farbe) |
`mosaicplot`| Mosaikplots (kategorielle Daten) |
`pairs` |Streudiagramm-Matrix |
`persp` |perspektivische Flächen |
`qqnorm` und `qqplot` | QQ–Plot |


Die wichtigsten *low-level* Grafikfunktionen nach @Ligges2008, verändert:

Funktion | Beschreibung |
:-------- | :------------ |
`abline` | Fügt eine Linie hinzu; diese kann horizontal, vertikal oder über Steigung und Achsenabschnitt definiert werden |
`arrows` | Pfeile| 
`axis` | Achsen|
`grid` |Gitternetz|
`legend` |Legende|
`lines` |Linien (schrittweise)|
`mtext` |Text in den Rändern|
`plot.new` |Grafik initialisieren|
`plot.window` |Koordinatensystem initialisieren|
`points` | Punkte|
`polygon` |(ausgefüllte) Polygone|
`pretty` |berechnet "hübsche" Einteilung der Achsen|
`segments` |Linien (vektorwertig)|
`text` |Text|
`title` |Beschriftung|

## Tuning mit `par`

Zur Vertiefung dieses Kapitels, empfehle ich @Ligges2008, Kapitel 8.1.3. <br>

Die Grafikebene in R ist aufgeteilt in drei Regionen (Abbildung \@ref(fig:aufteilung)) und hat innere und äußere Ränder. Die Ränder werden von unten im Gegenuhrzeigersinn durchnummeriert.

```{r aufteilung, echo = F, fig.cap = 'Aufteilung der Grafikfläche [@Ligges2008].', fig.width = 6, out.width = "80%"}
knitr::include_graphics('Regionen_und_Raender.png', auto_pdf = T)
```

Mit der Funktion `par` lassen sich sehr viele Einstellung der Grafik verändern. Viele Einstellungen übergibt die Funktion `plot` selbständig an `par`, zu.B. `log` (Logarithmieren der Achsen), `cex` (Größe eines Punkts) oder `col` (Farbe). Andere können aber nur durch Aufrufen der Funktion `par` verändert werden. Dazu gehören die inneren Ränder `mar` und die äußeren Ränder `oma`, die Aufteilung der Grafikebene mit `mfrow` oder `mfcol`.


```{block, type='rmdalert'}
Richtige Benutzung von `par`:

- Parameter setzen: `op <- par( ... )`
- plotten
- Parameter auf Standard zurück setzen: `par(op)`
```

Die Zuweisung `op <- par( ... )` speichert die Standardeinstellungen im Objekt `par`, bevor Sie sie ändern. Der Aufruf `par(op)` setzt Ihre Änderungen zurück. Das ist sehr praktisch, wenn Sie z.B. die Aufteilung der Grafikebene nicht mehr benötigen. Wenn Sie die Parameter nicht zurücksetzen, bleiben diese bestehen, bis das Grafikfenster geschlossen wird (z.B. mit `dev.off()`).

Um die Ränder zu verändern, rufen wir `par` auf und beschneiden die Ränder, damit Sie den Unterschied erkennen können.

```{r}
op <- par(mar = c(1, 1, 1, 1))
plot(my_date, meteo$MO_TT, type = 'b', xlab = 'Zeit', ylab = 'Temperatur [°C]', main = 'Klimadaten der DWD-Station Köln-Bonn', ylim = c(0, 30))

# Minimumtemperatur in rot
lines(my_date, meteo$MO_TN, col = 'blue')

# Maximumtemperatur in blau
lines(my_date, meteo$MO_TX, col = 'red')
```

Die Achsenbeschriftungen und die Zahlen haben jetzt nicht mehr genug Platz und verschwinden. Die Größe der Ränder wird in Zeilen angegeben, ist also relativ zur Gesamtgröße. Die Standardeinstellung ist `c(5, 4, 4, 2) + 0.1`.

Einige häufig genutzte Argumente in Grafikfunktionen und in `par` [nach @Ligges2008, verändert]. Schlagen Sie die Erklärungen dazu immer in `?par` oder `?plot` nach.

Funktion | Beschreibung|
:-------- | :------------ |
`axes` | Achsen sollen (nicht) eingezeichnet werden|
`bg` |Hintergrundfarbe|
`cex` |Größe eines Punktes bzw. Buchstaben|
`col` |Farben|
`las` |Ausrichtung der Achsenbeschriftung|
`log` |Logarithmierte Darstellung|
`lty`, `lwd` |Linientyp (gestrichelt, ...) und Linienbreite|
`main` |Überschrift |
`mar` |Größe der inneren Ränder für Achsenbeschriftung etc.|
`mfcol`, `mfrow` |mehrere Grafiken in einem Bild|
`pch` |Symbol für einen Punkt|
`type` |Typ (l für Linie, p für Punkt, b für beides, n für nichts)|
`usr` |Ausmaße der Achsen auslesen|
`xlab`, `ylab` |x-/y-Achsenbeschriftung|
`xlim`, `ylim` |zu plottender Bereich in x-/y- Richtung|
`xpd` |in die Ränder hinein zeichnen|

## Inhalt der live Einführung
- `plot`, `barplot`, `mfrow`
- Aufgaben \@ref(wahlbeteiligung), \@ref(zweitstimme) und \@ref(zweigrafiken).
- Speichern als pdf

<!--chapter:end:04-visualisieren.Rmd-->

```{r include=FALSE, cache=FALSE}
# Load libraries
library(fontawesome)
library(kableExtra)
library(tidyverse)

knitr::knit_hooks$set(document = function(x) {
  sub('\\usepackage{graphicx, color}',
      '\\usepackage{graphicx,xcolor}', x, fixed = TRUE)
}) 



# These are different helper functions for the book

colorize <- function(x, color) {
  if (knitr::is_latex_output()) {
    sprintf("\\textcolor{%s}{%s}", color, x)
  } else if (knitr::is_html_output()) {
    sprintf("<span style='color: %s;'>%s</span>", color, 
            x)
  } else x
}

file.name <- function(x) {
  if (knitr::is_latex_output()) {
    sprintf("\\texttt{%s}", x)
  } else if (knitr::is_html_output()) {
    sprintf("<span style='font-family: sans-serif; font-size: medium'>%s</span>",
            x)
  } else x
}
```
# Reproduzierbare Forschung {#reproduzieren}

```{block, type = 'rmdoutcomes'}
- Wichtigkeit der Reproduzierbarkeit erklären
- Begriff *literate programming* definieren
- Aufbau einer RMarkdown-Datei erklären
- Einen einfachen ersten reproduzierbaren Bericht schreiben
```

## Warum Reproduzierbarkeit in der Forschung wichtig ist

<iframe width="640" height="360" src="https://www.youtube.com/embed/4rBX6r5emgQ?list=PLjTlxb-wKvXOU4WW4p3qc4VKWTI4gLNUf" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>

## *Literate Programming* Idee von Donald Knuth
Die Idee, dass man den Code und die dazugehörige Interpretation (Text, Bericht etc.) nicht von einander trennen sollte, geht auf @Knuth1984 zurück. Mit *Literate Programming* meinte Knuth, dass Programme auch nichts anderes wie literatirsche Werke sind. Er setzte den Fokus darauf, mit Programmen menschlichen Benutzern zu erklären, was man den Computer machen lassen möchte. Also weg vom computer- hin zum menschzentrierten Zugang. So wird Programmieren und in unserem Fall die Datenanalyse verständlich und vor allem reproduzierbar. 

Leider ist es in unserer modernen Forschungslandschaft immer noch nicht Standard. Das Trennen von Analyseergebnissen und Berichten (Forschungsartikeln) sorgt für viele (unendeckte und unnötige) Fehler und Frust.

## Reproduzierbare Berichte mit R Markdown
R hat sein eigenes System von reproduzierbaren Berichten, genannt R Markdown [@Xie2018]. Es ist benutzerfreundlich und ermöglicht unterschiedliche Formate von Berichten, wie HTML-Dokumente, PDF-Dateien, Präsentationsfolien usw.

Es wird Sie vielleicht überraschen, aber das Skript, das Sie gerade lesen ist nichts anderes als ein "literarisch" programmierter Bericht in R Bookdown [@Xie2016], einem R-Paket speziell für lange R Markdown-Dokumente.

Wir werden vor allem mit R Notebooks arbeiten, die eine gute Interaktion zwischen dem geschriebenen Text und dem R-Code ermöglichen. Das Notebook kann sowohl in ein HTML-Dokument als auch in PDF oder Word als endgültiges Berichtdokument umgewandlet werden. Diesen Prozess nennt man *knit* (der Knopf in RStudio mit dem Wollknäuel).


## Wichtigste Regeln für Reproduzierbarkeit

<iframe width="640" height="360" src="https://www.youtube.com/embed/pjL2uP-fmPY?list=PLjTlxb-wKvXOU4WW4p3qc4VKWTI4gLNUf" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>

## Weiterführende Videos und Literatur

Die Playlist zu *Reporducible Research* finden Sie [hier](https://www.youtube.com/watch?v=4rBX6r5emgQ&list=PLjTlxb-wKvXOU4WW4p3qc4VKWTI4gLNUf).

Report Writing for Data Science in R [@Peng2019] (auf ILIAS)

## Inhalt der live Einführung

- Erstellen eines einfachen R Notebooks
- R-Code Chunks
- Einfache Layoutelemente: Überschriften, Listen, fett und kursiv

<!--chapter:end:05-rmarkdown.Rmd-->

```{r include=FALSE, cache=FALSE}
# Load libraries
library(fontawesome)
library(kableExtra)
library(tidyverse)

knitr::knit_hooks$set(document = function(x) {
  sub('\\usepackage{graphicx, color}',
      '\\usepackage{graphicx,xcolor}', x, fixed = TRUE)
}) 



# These are different helper functions for the book

colorize <- function(x, color) {
  if (knitr::is_latex_output()) {
    sprintf("\\textcolor{%s}{%s}", color, x)
  } else if (knitr::is_html_output()) {
    sprintf("<span style='color: %s;'>%s</span>", color, 
            x)
  } else x
}

file.name <- function(x) {
  if (knitr::is_latex_output()) {
    sprintf("\\texttt{%s}", x)
  } else if (knitr::is_html_output()) {
    sprintf("<span style='font-family: sans-serif; font-size: medium'>%s</span>",
            x)
  } else x
}
```
# Funktionen {#funktionen}

```{block, type = 'rmdoutcomes'}
- Den Aufbau von Funktionen in R beschreiben
- Den Aufruf von Funktionen in R erklären
- Einfache Funktionen selbst schreiben
- Fallunterscheidungen
- \texttt{for} Schleifen
```

Was genau Funktionen sind und wie man sie in R aufruft, lesen Sie bitte bei @Ligges2008 in Kapitel 4.1 nach. In diesem Kapitel des Skripts geht es um das Schreiben der eigenen Funktionen, Fallunterscheidungen mit `if`-`else` und `for` Schleifen.

## Eigene Funktionen schreiben
Funktionen sind eine großartige Möglichkeit, sich das Leben einfacher zu machen. Sie können repetitive Aufgaben erledigen, ohne dass wir ständig mit Copy und Paste hantieren müssen, machen unsere Notebooks übersichtlich und helfen, Fehler und Inkonsistenzen zu vermeiden. Als Faustregel gilt: wenn Sie ein Stück Code mehr als 2 Mal kopieren und abändern, wird es Zeit für eine Funktion `r emo::ji('smile')`.


Schauen wir uns ein Beispiel an. Als erstes würfeln wir ein paar Daten aus der Gleichverteilung mit unterschiedlichen Minima und Maxima und sehen uns die Zusammenfassung und die Standardabweichungen an.

```{r}
my_data <- data.frame(col1 = runif(20, min = 3, max = 10),
                      col2 = runif(20, min = 7, max = 12),
                      col3 = runif(20, min = 13, max = 100))
summary(my_data)
sapply(my_data, sd)
```

Ich möchte die Daten so transformieren, dass alle Variablen im Datensatz (d.h. Spalten) einen Mittelwert von 0 und eine Standardabweichung von 1 haben. Dazu ziehe ich den Mittelwert ab und teile durch die Standardabweichung. Das ist eine klassische Transformation (manchmal $z$-Transformation genannt), die manche Analysemethoden (z.B. Hauptkomponentenanalyse) als Vorbehandlung der Daten verlangen.

Erst einmal das Naheliegende: Transformation per Copy und Paste.

```{r}
my_data_trans <- data.frame(col1_trans = (my_data$col1 - mean(my_data$col1))/sd(my_data$col1),
                            col2_trans = (my_data$col2 - mean(my_data$col2))/sd(my_data$col1),
                            col3_trans = (my_data$col3 - mean(my_data$col3))/sd(my_data$col3))
```

Haben Sie den Fehler bemerkt? Ich habe einmal vergessen eine 1 durch eine 2 zu ersetzten. Das merke ich aber nur, wenn ich mir das Ergebnis ansehen. Die Standardabweichung in `col2_trans` ist nicht gleich 1.

```{r}
summary(my_data_trans)
sapply(my_data_trans, sd)
```

So etwas passiert sehr schnell und wird durch das Schreiben einer Funktion vermieden. 

Jede Funktionsdefinition beginnt mit der Wahl des Namens. Es ist eine gute Idee, sich einen konsistenten und sauberen Stil gleich am Anfang anzugewöhnen. Seien Sie nett zu Ihrem zukünftigen Ich und anderen Menschen, die Ihren Code lesen werden `r emo::ji('smile')`. Es ist ein guter Stil, Verben als Funktionsnamen zu nutzen, die beschreiben, was eine Funktion macht. In jedem Fall, **wählen Sie keine Namen, die schon für Funktionen oder Variablen vergeben sind!** Das würde die ursprünglichen Funktionen oder Variablen einfach überschreiben.

Wir nennen unsere Funktion `z_transform`, weil sie Daten $z$-transformiert. Bei zusammengesetzten Namen sollten Sie den Unterstrich verwenden. Das macht den Namen einfacher zu lesen.

```{r}
z_transofrm <- function(x) {
  (x - mean(x))/sd(x)
}
```

Bei jeder Funktionsdefinition arbeiten Sie drei Schritte ab:

1. Namen finden und das Skelett aus `Name_der_Funktion <- function() {}` hin schreiben.
2. Überlegen, welche Parameter die Funktion braucht und ob diese Standardwerte benötigen. Parameter zwischen die runden Klammern schreiben.
3. Funktionskörper (*body*), also die eigentliche Aufgabe der Funktion, hinschreiben.

Wir brauchen für unsere Funktion nur einen Parameter. Zwar sind die Namen der Parameter nicht ganz so wichtig wie Namen der Funktionen. Trotzdem sollte man hier konsistent sein: bei einfachen Vektoren sind `x`, `y`, `z` etc. völlig in Ordnung. Ansonsten sind Substantive ein guter Namensstil für Parameter.

Wir wenden die Funktion jetzt auf unseren Datensatz an.

```{r}
my_data_trans_2 <- data.frame(col1_trans = z_transofrm(my_data$col1),
                              col2_trans = z_transofrm(my_data$col2),
                              col2_trans = z_transofrm(my_data$col3))
summary(my_data_trans_2)
sapply(my_data_trans_2, sd)
```

Der Code ist viel aufgeräumter und übersichtlicher. Es ist viel klarer, was berechnet wird.

## Fallunterscheidungen

Manchmal möchte man unterschiedliche Berechnung innerhalb einer Funktion durchführen, je nach aufgestellter Bedingung. Daszu brauchen wir eine Fallunterscheidung, die durch einen `if`-`else` Ausdruck definiert wird. Jede Fallunterscheidung hat die folgende Form, wobei die zweite Bedingung nicht zwingend notwendig ist.

```{r eval = F}
if (Bedingung1) {
  # Code, der ausgeführt wird, wenn die erste Bedingung1 stimmt
} else if (Bedingung2) {
  # Code, der ausgeführt wird, wenn zweite Bedingung2 stimmt
} else {
  # Code, der ausgeführt wird, wenn keine der Bedingungung stimmt
}
```

Achten Sie genau darauf, wie `else if` und `else` positioniert werden, nämlich zwischen den beiden geschweiften Klammern.  Eine Fallunterscheidung kann auch mehr als zwei Bedingungen haben, aber man sollte nicht übertreiben. Wenn die Anzahl der Bedingungen zu hoch ist, sollte man nachdenken, ob das Problem nicht anders als mit `if`-`else` gelöst werden kann.

Wir schreiben eine Begrüßungsfunktion, die ja nach Tageszeit die richtige Begrüßung ausgibt.

```{r}
say_hello <- function(my_time) {
  if (my_time == 'Morgen') {
    'Guten Morgen'
  } else if (my_time == 'Mittag') {
    'Guten Tag'
  } else if (my_time == 'Abend'){
    'Guten Abend'
  } else {
    'In meiner Welt gibt es das nicht.'
  }
}
```

Wir rufen die Funktion auf mit einmal mit Abend und einmal mit abend.

```{r}
say_hello('Abend')
say_hello('abend')
```


## `for`-Schleifen (`for` *loops*)

Wenn wir unsere `say_hello` Funktion auf einen Vektor von Tageszeiten anwenden wollen, gibt es eine Warnung. 

```{r}
say_hello(c('Morgen', 'Mittag', 'Abend'))
```


Das liegt daran, dass die Auswertung der Bedingung eine Antwort der Länge 1 liefern muss: entweder `TRUE`, wenn die Bedingung stimmt, oder `FALSE`, wenn sie nicht stimmt. Bei einem Vektor ist die Antwort aber länger als 1 und die Funktion benutzt nur die erste Stelle der Antwort. Man sagt auch, dass die Funktion `say_hello` *nicht vektorisiert* sei, sie kann also nicht von sich aus auf einem Vektor arbeiten.

Damit man eine eine nicht vektorisierte Funktion auf einen Vektor anwenden kann, gibt es mehrere Möglichkeiten. Eine davon ist die sogen. `for` Schleife. Eine Schleife ist eine wiederholte Ausführung von Code, man sagt auch *Iteration*.

```{r}
begruessung <- c('Morgen', 'Mittag', 'Abend')

# Vektor für Ergebnisse erstellen
ergebnis <- vector(mode = 'character', length = 3)

# For Schleife über die Zahlenfolge 1:3 mit Hilfe der Dummy-Variablen i
for (i in 1:3) {
  ergebnis[i] <- say_hello(begruessung[i])
}

# Ergebnis ansehen
ergebnis
```


Eine `for` Schleife braucht drei Bestandteile:

1. Einen Datencontainer, in unserem Fall den Vektor `ergebnis`, in dem die Ergebnisse der Schleifendurchläufe gespeichert werden. Dieser Vektor muss vorher erstellt werden.
2. Eine Dummy-Variable (Hilfsvariable), die in jedem Schleifendurchlauf einen anderen Wert annehmen wird. Dadurch entsteht erst die Schleife. Die Dummy-Variable bei uns heißt `i` und nimmt Werte zwischen 1 und 3 (also 1, 2 und 3) an. Es gibt also drei Schleifendurchgänge.
3. Den Schleifen-Körper, in unserem Fall die Funktion `say_hello`. Das ist der Code, der wiederholt ausgeführt werden soll.

Später werden wir effiziente Funktionen kennen lernen, die ohne Schleifen Funktionen wiederholt ausführen (iterieren) können.

## Weiterführende Literatur

@Ligges2008, Kapitel 4.1 für technische Beschreibung des Aufrufs von Funktionen

Dieses Kapitel orientiert sich stark an @Wickham2017, Kapitel 19

## Inhalt der live Einführung

- Funktionsaufruf
- Funktionen selbst schreiben
- Aufgabe \@ref(fledermaus): `if` - `else` Bedingungen und `for` Schleifen

<!--chapter:end:06-funktionen.Rmd-->

```{r include=FALSE, cache=FALSE}
# Load libraries
library(fontawesome)
library(kableExtra)
library(tidyverse)

knitr::knit_hooks$set(document = function(x) {
  sub('\\usepackage{graphicx, color}',
      '\\usepackage{graphicx,xcolor}', x, fixed = TRUE)
}) 



# These are different helper functions for the book

colorize <- function(x, color) {
  if (knitr::is_latex_output()) {
    sprintf("\\textcolor{%s}{%s}", color, x)
  } else if (knitr::is_html_output()) {
    sprintf("<span style='color: %s;'>%s</span>", color, 
            x)
  } else x
}

file.name <- function(x) {
  if (knitr::is_latex_output()) {
    sprintf("\\texttt{%s}", x)
  } else if (knitr::is_html_output()) {
    sprintf("<span style='font-family: sans-serif; font-size: medium'>%s</span>",
            x)
  } else x
}
```
# Tidyverse {#tidyverse}

```{block, type = 'rmdoutcomes'}
- Kernpakete aus `tidyverse` benennen
- ein einfaches Workflow (Daten einlesen, zusammenfassen, darstellen) mit `tidyverse` durchführen
- Funktionen des Pakets `dplyr` für Datentransformation anwenden
```

`tidyverse` ist eine Sammlung von R-Pakete, die explizit für Datenanalyse entwickelt wurden (https://www.tidyverse.org/). `tidyverse` versucht durch gemeinsame Philosophie in Design, Grammatik und Datenstruktur die Datenanalyse zu erleichtern (https://design.tidyverse.org/). Auch wenn `tidyverse` auf den ersten Blick etwas fremd erscheint, es ist ein Teil von R, kein eigenes Universum. Es ist also völlig in Ordnung, R-Basisfunktionen mit Funktionen aus `tidyverse` zu mischen.

Das wichtigste Einführungsbuch zu `tidyverse` ist sicherlich **R4DS**: "R for Data Science" [@Wickham2017], das Sie kostenlos online lesen können (https://r4ds.had.co.nz/).

## Grundpakete

`tidyverse` enthält folgende Grundpakete, die alle installiert werden, wenn Sie `install.packages('tidyverse')` eingeben.

Paketname | Kurzbeschreibung|
:-------- | :------------ |
`ggplot2`| Visualisierung |
`dplyr`| Datentransformation |
`tidyr`| Datenbereinigung |
`readr`| Daten einlesen  |
`purrr`| Funktionale Programmierung (Funktionen auf Objekte anwenden) |
`tibble`| Erweiterung von `data.frame` |
`stringr`| Funktionen für Strings, d.h. Textvariablen |
`forcats`| Funktionen für `factor` |

Jedes dieser Pakete hat ein Cheat Sheet, eine übersichtliche Zusammenstellung der Funktionen des Pakets. Sie bekommen die Cheet Sheats über die `tidyverse`-Seite (https://www.tidyverse.org/packages/), indem Sie auf das jeweilige Paket klicken und zum Abschnitt 'Cheatsheet' scrollen.

## Der Workflow

### Daten einlesen

Sie kennen bereits die sehr umfangreiche Funktion `read.table()` zum Einlesen der Daten. Die Funktion `read_delim()` ist die allgemeinste Funktion der `read_*` Familie aus `readr` in `tidyverse`; `read_csv()` und `read_csv2()` sind jeweils für komma- und strichpunkt-getrennte Datensätze gedacht. Man könnte berechtigterweise fragen, warum eine neue Funktion für etwas erfinden, was es schon gibt. Die Autoren von `tidyverse` versprechen Konsistenz und Geschwindigkeit. Ersteres war schon immer ein Problem von R, da es nicht von Computerspezialisten, sondern von Anwendern erfunden wurde. Daher ist eine Vereinheitlichung durch `tidyverse` mehr als willkommen. Und Geschwindigkeit ist spätestens bei größeren Datensätzen ein wichtiger Punkt.

Wir sehen uns erneut Daten des Deutschen Wetterdienstes an, wie im Kapitel \@ref(visualisieren). Nur diesmal sind es Stundenwerte für relative Luftfeuchte (%) und Lufttemperatur (°C). Die Daten von drei Wetterstationen, nämlich Hof, Frankfurt und Köln-Bonn, befinden sich in der Datei `r file.name("Drei_Stationen.csv")` Beim Einlesen zeigt Ihnen `read_delim()` bereits, welche Spalten und welche Datentypen es erkennt, mit `trim_ws = T` werden Leerzeichen aus Spalten entfernt.

```{r}
library(tidyverse)

temp_humid <- read_delim('Drei_Stationen.csv', delim = ';',
                         trim_ws = T)
```
Eine weitere Kontrolle bietet die Funktion `print()`, die das eingelesene Ergebnis übersichtlich (und im Notebook interaktiv) darstellt. Sie müssen hier nicht mehr `head()` verwenden, da grundsätzlich nur die ersten 10 Zeilen dargestellt werden.

```{r}
print(temp_humid)
```

Das gleiche Ergebnis bekommen Sie auch ohne `print()`, wenn Sie wie gewohnt den Namen des Objekts tippen.

```{r}
temp_humid
```


In diesem Datensatz sind folgende Parameter (Spalten) enthalten (s. Datensatzbeschreibung des DWDs)

Parameter | Beschreibung |
:--------|:---------------|
STATIONS_ID | Stationsidentifikationsnummer |
MESS_DATUM | Zeitstempel im Format yyyymmddhh |
QN_9 | Qualitätsniveau der nachfolgenden Spalten |
TT_TU | Lufttemperatur in 2m Höhe °C |
RF_TU | relative Feuchte % |
eor | Ende data record


```{r}
class(temp_humid)
```

Das Objekt `temp_humid` ist ein sogen. Tibble, ein `data.frame` mit "modernem" Verhalten. Z.B. gibt die Funktion `print()` nur die ersten 10 Zeilen aus, die Datentypen in den Spalten werden in hellgrau zwischen '<>' mit angegeben etc. Mehr zu Tibbles finden Sie in Kapitel 10 "Tibbles" in R4DS.

Ein weiteres Paket, dass zwar nicht zum Kern von `tidyverse` gehört, jedoch trotzdem extrem nützlich ist, heißt `lubridate`. Es hilft, Text in richtige Datums-Objekte zu transformieren (ohne sich die kryptischen Datumsformate von R merken zu müssen). Wir transformieren die Spalte `temp_humid$MESS_DATUM` in ein richtiges Datum mit Uhrzeit.

```{r}
library(lubridate)

temp_humid$MESS_DATUM <- ymd_h(temp_humid$MESS_DATUM)

print(temp_humid)
```

### Daten zusammenfassen

Die drei Wetterstationen haben folgende IDs:

```{r}
station_ids <-  tibble('Hof' = '2261', 'Frankfurt' = '1420', 'Koeln' = '2667')
```


Ich möchte wissen, wie viele Messpunkte es pro Station gibt:


```{r}
temp_humid %>% 
  count()
```

Die Zeichenkombination `%>%` heißt Pipe-Operator (*pipe*) und wird als 'und dann' gelesen (*then*). Der Ausdruck `temp_humid %>% count()` heißt also: nimm `temp_humid` und dann zähle die Einträge. Der Pipe-Operator ist die Kernphilosophie von `tidyverse` und wird Ihnen überall begegnen. Der Operator stammt aus dem Paket `magrittr` (https://magrittr.tidyverse.org/). Seine Hauptaufgabe ist es, den Code übersichtlicher und besser lesbar zu machen (vielleicht nicht gleich zu Beginn der Lernkurve aber schon sehr bald `r emo::ji('smile')`).

Die Funktion `count()` gehört zum Paket `dplyr`, das für Datentransformationen zuständig ist. Dieses Paket enthält 5 Grundfunktionen (alle nach Verben benannt `r emo::ji('smile')`):

Funktion | Bedeutung |
:-----------|:-----------|
`filter()` | Wähle Daten anhand ihrere Werte |
`arrange()` | Sortiere Zeilen |
`select()` | Wähle Variablen anhand ihrere Namen |
`mutate()` | Erstelle neue Variablen als Funktionen vorhandener Variablen |
`summarize()` | Fasse Daten zusammen |

Ich möchte nun wissen, wie viele Messpunkte es für Köln-Bonn gibt. `tidyverse` ist konsistent: jeder Aufruf einer Funktion aus `dplyr` gibt ein `tiblle` zurück (und nicht mal `data.frame` mal Vektor).

```{r}
temp_humid %>% 
  filter(STATIONS_ID == station_ids$Koeln) %>%
  count()
```

### Daten plotten

Wir wählen nur die Station Köln-Bonn und plotten die Stundenwerte der Temperatur mit dem Paket `ggplot2`.

```{r}
# Köln-Bonn wählen
koeln <- temp_humid %>% 
  filter(STATIONS_ID == station_ids$Koeln)

koeln
```

```{r}
# Plotten
ggplot(data = koeln, aes(x = MESS_DATUM, y = TT_TU)) + 
  geom_line()
```

Sie werden sehr bald schon das Paket `ggplot2` nicht mehr missen wollen. Es erstellt mit wenig Aufwand sehr ansehnliche Grafiken. Natürlich müssen Sie, wie in Base-R auch, für professionelle Grafiken nacharbeiten.

`ggplot2` folgt einer sogen. Grafikgrammatik (*grammer of graphics*), indem es seine Grafiken mit '+' aufbaut. Erst sagt man in der Funktion `ggplot()` welchen Datensatz man plotten möchte, was auf die x- und y-Achse kommt und ob man z.B. Farbe für Gruppen in Daten möchte. All diese sichtbaren Elemente nennt man Ästhetiken (Parameter `aes`). Erst wenn diese 'Formalien' geklärt sind, sagt man, welche Form der Darstellung man möchte. Im oberen Beispiel ist es ein Linienplot. Alle Darstellungsarten in `ggplot2` beginnen mit `geom_*()` und sind daher konsistent benannt. Die Informationen zu Daten, x-, y-Achse etc. werden an die `geom_*()`-Funktionen von der Mutterfunktion `ggplot()` weiter vererbt. Daher sind die Klammern in `geom_line()` leer.

Wir wollen nun die Monatsmittelwerte für die Temperatur berechnen und diese darstellen. Als erstes erstellen wir zwei neue Spalten, die jeweils das Jahr und den Monat beinhalten. Die beiden neuen Spalten werden am Ende von  `temp_humid` angehängt.

```{r}
temp_humid <- mutate(temp_humid, 
                     year = year(temp_humid$MESS_DATUM),
                     month = month(temp_humid$MESS_DATUM))

temp_humid
```

Jetzt können wir einen neuen Datensatz mit den Mittelwerten erstellen. Dafür gruppieren wir erst einmal die Daten nach `STATIONS_ID`, `year` und `month`. Die Mittelwerte sollen ja je Station, Jahr und Monat berechnet werden.

```{r}
by_month <- group_by(temp_humid, STATIONS_ID, year, month)
monthly_means <- summarize(by_month, mean_T = mean(TT_TU), mean_RH = mean(RF_TU))

monthly_means
```

Die Struktur von `monthly_means` zeigt uns, dass es sich um gruppierte Daten handelt.

```{r}
str(monthly_means)
```

Da wir aber mit den Daten weiter rechnen wollen, ist es besser, die Gruppierung wieder aufzugeben. Es könnte sonst später Fehlermeldungen geben.

```{r}
monthly_means <- ungroup(monthly_means)
```


Um die Daten als Zeitreihen zu plotten, erstellen wir noch eine ordentliche Zeit-Spalte. Die Funktion `parse_date_time()` kann aus Character richtige Datums-Zeitobjekte erstellen. Sie ist allgemeienr als die oben verwendete `ymd()` Funktion, da man hier das Format explizit angeben kann. In unserem Fall ist das Format 'ym' für Jahr und Monat.

```{r}
monthly_means <- monthly_means %>%
  mutate(my_date = parse_date_time(paste0(monthly_means$year,
                  monthly_means$month), 'ym', tz = 'CET'))
```


```{r}
ggplot(data = monthly_means, aes(x = my_date, y = mean_T, 
            col = factor(STATIONS_ID))) + 
  geom_line() + 
  labs(x = 'Time', y = 'Temperature (°C)', color = 'Station')
```

Wir werden in eine spätere Kapitel auf `ggplot2` genauer eingehen. Fürs Erste soll es als Appetithappen reichen `r emo::ji('cake')`.

## Weiterführende Literatur und Videos

- R4DS: Kapitel 5 "Data transformation", 11 "Data import"

- Eine live Analyse des Hauptautors von `tidyverse`, Hadley Wickham. Empfehlenswert, auch wenn er viel zu schnell tippt `r emo::ji('smile')`.

<iframe width="913" height="432" src="https://www.youtube.com/embed/go5Au01Jrvs" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>

## Inhalt der live Einführung

Verschiedene Funktionen aus `tydiverse` anhand der Aufgaben \@ref(fledermaus3) und \@ref(klausur)

<!--chapter:end:07-tidyverse.Rmd-->

```{r include=FALSE, cache=FALSE}
# Load libraries
library(fontawesome)
library(kableExtra)
library(tidyverse)

knitr::knit_hooks$set(document = function(x) {
  sub('\\usepackage{graphicx, color}',
      '\\usepackage{graphicx,xcolor}', x, fixed = TRUE)
}) 



# These are different helper functions for the book

colorize <- function(x, color) {
  if (knitr::is_latex_output()) {
    sprintf("\\textcolor{%s}{%s}", color, x)
  } else if (knitr::is_html_output()) {
    sprintf("<span style='color: %s;'>%s</span>", color, 
            x)
  } else x
}

file.name <- function(x) {
  if (knitr::is_latex_output()) {
    sprintf("\\texttt{%s}", x)
  } else if (knitr::is_html_output()) {
    sprintf("<span style='font-family: sans-serif; font-size: medium'>%s</span>",
            x)
  } else x
}
```
# Aufgabensammlung

## Erste Schritte

### Ars Haushaltsbuch

Der angehende Datenanalyst Ar Stat möchte dem Rat seiner Mutter folgen und ein Haushaltsbuch anlegen. Als erstes möchte er sich einen Überblick über seine Ausgaben in der Uni-Mensa verschaffen und erstellt die folgende Tabelle:

<br>

```{r, results='asis', echo = F}

tab = data.frame(Wochentag = c('Montag', 'Dienstag', 'Mittwoch', 'Donnerstag', 'Freitag'), Ausgaben = c(2.57, 2.90, 2.73, 3.23, 3.90))
knitr::kable(tab, 
             #format = 'latex',
             caption = 'Ars Mensaausgaben', booktabs = T,
             format.args = list(decimal.mark = ',')) %>%
  kable_styling(bootstrap_options = "striped", full_width = F,
                position = "left")
```


1. Wie viel hat Ar insgesamt in der Woche ausgegeben?
2. Wie viel hat er im Schnitt pro Tag ausgegeben?
3. Wie stark schwanken seine Ausgaben?

Leider hat Ar sich beim übertragen der Daten vertippt. Er hat am Dienstag seine Freundin zum Essen eingeladen und 7,95 € statt 2,90 € ausgegeben.

4. Korrigieren Sie Ars Fehler.
5. Wie verändern sich die Ergebnisse aus den Teilaufgaben 1 bis 3 Warum?


## Daten in R

### Bestandesaufnahme im Wald {#bestandesaufnahme}

Ar Stat arbeitet als HiWi in der AG Ökosystemforschung und soll im Nationalpark Eifel eine Bestandsaufnahme durchführen (d.h. Baumhöhen und -durchmesser vermessen). Er notiert den BHD (Brusthöhendurchmesser) und die Art der Bäume.


1.  Lesen Sie den Datensatz `r file.name("BHD.txt")` ein und ordnen Sie ihn der Variable `BHD` zu.
2. Erstellen Sie einen Vektor `a` mit Baumnummern. Von welcher Art sind die Elemente des Vektors `a`?
3. Fügen Sie die Datensätze `BHD` und `a` zu einem `data.frame` zusammen und benennen Sie die Spalten sinnvoll.
4. Löschen Sie den Vektor `a`.
4. Lesen Sie den Datensatz `r file.name("Art.txt")` ein und ordnen Sie ihn der Variablen `art` zu.
5. Fügen Sie die Art in den `data.frame` ein.
6. Erstellen Sie eine Tabelle mit der Anzahl der jeweiligen Arten. Nutzen Sie die Funktion `table`.
7. Speichern Sie die Tabelle mit `write.table`.


## Daten visualisieren, Teil I: Fokus auf R

### Wahlbeteiligung bei der Bundestagswahl 2017 {#wahlbeteiligung}

Bauen Sie die Grafiken aus der Einführung nach (Abbildung \@ref(fig:wahlbeteiligung)).

```{r wahlbeteiligung, echo = F, fig.cap = 'Wahlbeteiligung bei den Bundestagswahlen. Quelle: Der Bundeswahlleiter.', fig.width = 6, out.width = "100%"}
knitr::include_graphics('Wahlbeteiligung.png', auto_pdf = T)
```


1. Lesen Sie den Datensatz `r file.name('Wahlbeteiligung.csv')` in R ein und ordnen Sie ihn dem Objekt `bet` zu. Der Datensatz hat einen *header* und haben einen Strichpunkt als Spaltentrenner.
2. Sehen Sie sich die Struktur und die ersten und letzten 6 Zeilen des Datensatzes an.
2. Stellen Sie die Wahlbeteiligung als Funktion der Zeit in einem Streudiagramm dar. Wählen Sie die passende Darstellungsform `type`.
2. Beschriften Sie die Grafik.
2. Speichern Sie die Grafik als pdf ab.


### Zweitstimme bei der Bundestagswahl 2017 {#zweitstimme}

Bauen Sie die Grafiken aus der Einführung nach (Abbildung \@ref(fig:zweitstimme)).

```{r zweitstimme, echo = F, fig.cap = 'Zweitstimme bei der Bundestagswahl 2017. Quelle: Der Bundeswahlleiter.', fig.width = 6, out.width = "100%"}
knitr::include_graphics('Zweitstimme.png', auto_pdf = T)
```


1. Lesen Sie den Datensatz `r file.name('Zweitstimme.csv')` in R ein und ordnen Sie ihn dem Objekt `zweit` zu. Der Datensatz hat einen *header* und haben einen Strichpunkt als Spaltentrenner.
2. Sehen Sie sich die Struktur und die ersten und letzten 6 Zeilen des Datensatzes an.
2. Stellen Sie die die Zweitstimmen pro Partei in einem Säulendiagramm dar. Sortieren Sie die Zweitstimmen in absteigender Reihenfolge.
2. Beschriften Sie die Grafik.
2. Speichern Sie die Grafik als pdf ab.

### Ergebnisse der Bundestagswahl in einer Grafik {#zweigrafiken}

Stellen Sie beide Grafiken nebeneinander dar wie in Abbildung (\@ref(fig:zweigrafiken)) gezeigt.

```{r zweigrafiken, echo = F, fig.width = 6, fig.cap = 'Ergebnisse der Bundestagswahl 2017. Quelle: Der Bundeswahlleiter.', fig.width = 6, out.width = "100%"}
knitr::include_graphics('Zwei_grafiken.png', auto_pdf = T)
```


### Einen zu großen weißen Rand vermeiden {#weisserrand}

Bei Berichten haben Abbildungen meistens keine Überschrift, da alles in der Bildunterschrift erklärt wird. Wenn man die Überschrift beim plotten weglässt, die Standardeinstellungen für die Ränder aber beibehält, entsteht ein zu großer weißer Rand um die Grafik. Diesen wollen wir nun abschalten.

1. Kopieren Sie den Code zum Plotten der Temperaturen aus dem Kapitel \@ref(visualisieren).
1. Stellen Sie oben und rechts einen Rand von 0.1 Zeilen ein.
1. Speichern Sie die Grafik als pdf ab.

### Spielen mit der Funktion `par`
 Setzen Sie die Übung \@ref(weisserrand) fort. Denken Sie an den richtigen Aufruf mit der Zuweisung von `op <- par( ... )`!

1. Probieren Sie die Größeneinstellung `cex = 2` in `plot` aus. Testen Sie unterschiedliche Werte.
1. Probieren Sie die Einstellungen `cex.axis`, `cex.lab` und `cex.main` in `par` aus. 
1. Probieren Sie die Einstellung `col` in `plot` aus.
1. Probieren Sie die Einstellungen `col.axis`, `col.lab` und `col.main` aus. 
1. Probieren Sie die Schrifteinstellungen aus. Dazu stellen Sie den Parameter `family` in `par` auf "serif", "sans" oder "mono".
1. Probieren Sie die Parameter `font.lab = 2` und `font.axis = 2` direkt in `plot` aus. Zahlen 1 bis 5 stehen jeweils für normal, fett, kursiv, fett-kursiv und symbolisch.

## Reproduzierbare Berichte mit R Markdown

### Erster eigener Bericht

Erstellen Sie ein R Notebook aus den Notizen der ersten 3 R-Sessions.

## Eigene Funktionen schreiben

### R-Hausaufgaben

An dem Kurs "Einführung in R" nehmen 49 Studierende teil. Der Leistungsnachweis besteht aus Hausaufgaben, die insgesamt mit 100 Punkten bewertet werden. Ab 50 Punkten gilt der Kurs als bestanden. 

1. Lesen Sie den Datensatz `r file.name("R-HAs.txt")`, der die Endpunkte enthält, ein.
2. Ermitteln Sie, wie viele Teilnehmer bestanden und wie viele nicht bestanden haben.


### Fledermäuse, die Zweite {#fledermaus}

Wir beschäftigen uns erneut mit den Fledermäusen.

1. Lesen Sie den korrigierten(!) Datensatz  `r file.name("Fledermaus_cor.txt")` ein.
2. Schreiben Sie eine Funktion, die den Entwicklungsstand der Tiere klassifiziert. Nutzen Sie dazu die ad hoc Regel: Individuum < 5 cm ist ein Jungtier, sonst erwachsen.
3. Erstellen Sie eine ordinal-skalierte Variable `alter` mit dem Entwicklungsstand der Tiere.
3. Wie viele Erwachsene und wie viele Jungtiere wurden vermessen?

## Tidyverse

### Fledermaus, die Dritte {#fledermaus3}
1. Wiederholen Sie die Aufgabe \@ref(fledermaus) mit `tidyverse`
2. Berechnen Sie die Mittelwerte der Größe für weibliche und männliche Individuen.
3. Berechnen Sie die Mittelwerte der Größe für die Kategorien weiblich, männlich, Jungtier und erwachsen getrennt.


### Unfaire Klausur? {#klausur}

Ar belegt im 4. Semester die Veranstaltung "Spaß mit R". Bei der Klausur gibt es 2 Aufgabengruppen mit jeweils 60 Punkten. Aufgabengruppe 1 wird an Studierende auf ungeraden Sitzplätzen und  Aufgabengruppe 2 an Studierende auf geraden Sitzplätzen ausgegeben. 

1. Lesen Sie den Datensatz `r file.name("Klausurpunkte.txt")` ein.
1. Überprüfen Sie Ars Vermutung, dass die Aufgabengruppe 1 im Schnitt leichter war als Aufgabengruppe 2 (d.h. in der Gruppe 1 im Schnitt mehr Punkte erzielt wurden).
  <ol start="i">
  <li>Berechnen Sie erst die Mittelwerte pro Gruppe.</li>
  <li>Testen Sie dann mit einem Permutationstest, ob die Mittelwerte signifikant verschieden sind. Adaptieren Sie den Code aus dem Tutorial Hypothesentests_1.Rmd.</li>
</ol>



## Daten visualisieren, Teil II: Fokus auf Daten

### Zeitreihen aus der Langen Bramke (Harz)

Im Harz wurden über eine längere Zeit Niederschlag, Abfluss und Temperatur gemessen.

1. Laden Sie den Datensatz `r file.name("Data.dat")`.
2. Stellen Sie die Temperatur in einem Streudiagramm dar. Welche Darstellungsart (Argument `type` in `plot`) erscheint Ihnen am sinnvollsten? 
3. Beschriften Sie die Graphik und fügen Sie einen Titel hinzu.
4. Speichern Sie die Graphik als pdf ab.
5. Stellen Sie die Niederschläge in einem Diagramm dar. Wählen Sie einen geeigneten Darstellungstyp mit `type` (Tipp: geben Sie für die Hilfe `?plot` in die Konsole ein).

### Temperatur-Datensatz

Die Datei `r file.name("Temperatur.csv")` aus @Zuur2009a enthält Messungen von Temperatur, Salinität und Chlorophyl a an 31 Orten entlang der dänischen Küste. Die Daten stammen vom dänischen Institut RIKZ (Monitoringprogramm MWTL: Monitoring Waterstaatkundige Toestand des Lands). Die Messungen wurden zwischen 1990 und 2005 durchgeführt mit einer Häufigkeit von 0-4 mal pro Monat je nach Jahreszeit.

1. Lesen Sie den Temperatur-Datensatz `r file.name("Temperatur.csv")` ein.
1. Berechnen Sie die Anzahl der Messwerte, Monatsmittelwerte für alle Stationen, sowie die Standardabweichungen.
1. Stellen Sie die Monatsmittel der Temperatur als Linien dar.
1. Beschriften Sie die Grafik sinnvoll.
1. Fügen Sie die Standardabweichungen als Band hinzu.
1. Speichern Sie die Grafik als pdf ab.

### Temperatur-Datensatz, revisited
1. Berechnen Sie die Monatsmittelwerte und Standardabweichungen je Station. Tipp: `group_by(Station, Month)`.
1. Stellen Sie die Daten mit einem Fehlerband dar und speichern Sie sie ab.
1. Stellen Sie die Daten als Punkte mit Fehlerbalken dar und speichern Sie sie ab. Zur Orientierung, das Ergebnis sollte so aussehen wie in Abbildung (\@ref(fig:temperrors)).

```{r temperrors, echo = F, fig.width = 6, fig.cap = 'Mittelwerte der Temperatur je Station [@Zuur2009a]', fig.width = 6, out.width = "100%"}
knitr::include_graphics('Temp_error_bars.png', auto_pdf = T)
```


### Artenvielfalt in Grasländern
Sie erhalten Daten aus dem Grasland-Monitoring im Yellowstone Nationalpark und dem National Bison Range (USA). Das Ziel des Monitorings ist die Untersuchung möglicher Änderungen der Biodiversität und des Zusammenhang mit Umweltfaktoren. Biodiversität wurde durch die Anzahl unterschiedlicher Arten quantifiziert. Insgesamt haben die Forscher ca. 90 Arten in 8 Transekten kartiert. Die Aufnahmen wurden alle 4 bis 10 Jahre wiederholt. Insgesamt liegen 58 Beobachtungen vor. Die Daten sind in der Datei `r file.name("Vegetation2.xls")` gespeichert.

1. Laden Sie den Datensatz in R und sehen Sie sich das Ergebnis genau mit  `str`, `head` und `tail` an. Diese Aufgabe dient dazu, das Einlesen von Excel-Dateien mit `tidyverse` zu erarbeiten. Tipp: nutzen Sie die Funktion `read_xls()` in der Bibliothek `readxl`. Lesen Sie genau in der Hilfe nach, wie Sie *ein bestimmtes* Tabellenblatt einlesen können.

1. Kurze explorative Analyse: Berechnen Sie die Anzahl der Messungen, den Mittelwert und die Standardabweichung der Artenzahl (Variable  `R`) pro Transekt. 

1. Plotten Sie die Artenzahl gegen die Variable `BARESOIL` (Anteil von unbewachsenem Boden). Färben Sie die Punkte je nach Transekt unterschiedlich ein. Tipp: Transekt als `as.factor()` konvertieren.

1. Fügen Sie eine glättende Linie ohne Konfidenzband hinzu, die alle Punkte unabhängig vom Transekt berücksichtigt (Abschnitt 5.2 in ggplot2 Buch). 

1. Beschriften Sie die Graphik (auch die Legende!) sinnvoll und speichern Sie sie als pdf ab.

1. Stellen Sie die Artenzahl je Transekt als Zeitreihe dar. Die Symbole sollen sowohl Punkte als auch Linien sein. Skalieren Sie die Größe der Punkte je nach Anteil des unbewachsenen Bodens (Abschnitt 6.2 im ggplot2 Buch).

1. Beschriften Sie die Grafik (auch die Legenden!) sinnvoll und speichern Sie sie als pdf ab.

1. Setzen Sie nun beide Grafiken neben einander, platzieren Sie die Legenden (ja nach gewähltem Layout) sinnvoll und speichern Sie die Grafiken ab.


### Tracerversuche
Im Waldstein wurden Tracerversuche mit dem Farbstoff Brilliant Blue durchgeführt und die gefärbten Bodenprofile *binärisiert* (d.h. in ein schwarz-weiß Bild umgewandelt). Schwarze Pixels stellen gefärbten Boden und weiße ungefärbten dar. Aus diesen Binärbildern wurde anschließend eine Reihe von Kenngrößen berechnet.

1. Lesen Sie die Datei `r file.name("Waldstein2005_ind.txt")` ein.  Die Tiefe eines Profils ist 579 Pixel und es liegen 6 Profile untereinander in der Spalte d.
1. Berechnen Sie die 5%, 50% und 95% Quantile des Färbeanteils (Index d) der 6 Profile.
1.  Stellen Sie den Median des Anteils der Färbung mit der Tiefe dar und fügen Sie die Quantile als transparente Fläche hinzu (Tipp: `polygon`).

## Tidy data

### Wasserentnahme mit Datenquelle Excel
Wir beschäftigen uns mit dem Einlesen und bereinigen von Daten aus Exceldateien. Dazu nutzen wir das Beispiel aus einer der ersten Sitzungen zur Wasserentnahme in der EU.

1. Sehen Sie sich die Strukture der Datei `r file.name("TEN000021586860138332.xlsx")` an und lesen Sie sie ein. Nutzen Sie dazu die Funktion `read_xlsx()` aus dem Paket readxl.
2. Bereinigen Sie den Datensatz und konvertieren Sie ihn in *tidy*. Nutzen Sie dazu die Funktion `pivot_longer()`.
3. Finden und korrigieren Sie den Fehlwert.
4. Filtern Sie die Einträge für die EU heraus und behalten Sie nur die einzelnen Länder bei.
5. Stellen Sie die Änderung der Wasserentnahme pro Land dar.

### Wasserentnahme mit Datenquelle EUROSTAT direkt

Wir können die Datenbank EUROSTAT direkt über ihr API (Application Programming Interface) ansprechen. Leider ist das herunter geladene Datenformat sehr umständlich. Um uns Programmierarbeit zu sparen, nutzen wir das Paket eurostat, das die Daten aus der Datenbank herunterlädt und gleich ordentlich formatiert.

1. Installieren Sie das Paket eurostat und sehen Sie sich das Tutorial für das Paket an (https://ropengov.github.io/eurostat/articles/website/eurostat_tutorial.html)
2. Durchsuchen Sie die Datenbank nach allen Datensätzen, die das Wort "water" enthalten und darin das Wort "abstraction".
3. Laden Sie den entsprechenden Datensatz herunter (env_wat_abs).
4. Das Paket skimr bietet Zusammenfassungsfunktionen für Datensätze, die man auch in der Pipe benutzen kann. Installieren Sie das Paket und wenden Sie die Funktion `skim()` auf den heruntergeladenen Datensatz an.
4. Welche Wasserquellen und Nutzer sind im Datensatz enthalten (https://appsso.eurostat.ec.europa.eu/nui/show.do?dataset=env_wat_abs&lang=en)?
4. Stellen Sie die Wasserentnahme pro Einwohner dar (Gesamtentnahme aus allen Quellen: wat_proc == 'ABST' & wat_src == 'FRW').
4. Berechnen Sie die Gesamtmenge des entnommenen Wassers für alle Länder je Quelle (Fresh surface water und Fresh ground water).
4. Stellen Sie diese Daten als Punktdiagramm, als Balkendiagramm und als Flächendiagramm dar. Was ist das Problem mit dem Flächendiagramm?

<!-- ## Effizientes Programmieren -->

<!-- ### Lagerungsdichten -->
<!-- Auf 10 verschiedenen landwirtschaftlichen Feldern wurden im Oberboden je 25 Stechzylinder entnommen. -->

<!-- 1. Lesen Sie den Datensatz  `r file.name("Bodendaten.txt")` ein. -->
<!-- 1. Bestimmen Sie die mittlere Lagerungsdichte pro Feld. -->

<!-- ### Temperatur-Datensatz, revisited -->

<!-- 1. Laden Sie den Temperatur-Datensatz aus @Zuur2009a, Datei `r file.name("Temperatur.csv")`. -->
<!-- 1.  Berechnen Sie die Jahresmittelwerte je Station. (Tipp: Hilfe von `tapply` genau lesen!) -->

<!--chapter:end:19-aufgabensammlung.Rmd-->

```{r include=FALSE, cache=FALSE}
# Load libraries
library(fontawesome)
library(kableExtra)
library(tidyverse)

knitr::knit_hooks$set(document = function(x) {
  sub('\\usepackage{graphicx, color}',
      '\\usepackage{graphicx,xcolor}', x, fixed = TRUE)
}) 



# These are different helper functions for the book

colorize <- function(x, color) {
  if (knitr::is_latex_output()) {
    sprintf("\\textcolor{%s}{%s}", color, x)
  } else if (knitr::is_html_output()) {
    sprintf("<span style='color: %s;'>%s</span>", color, 
            x)
  } else x
}

file.name <- function(x) {
  if (knitr::is_latex_output()) {
    sprintf("\\texttt{%s}", x)
  } else if (knitr::is_html_output()) {
    sprintf("<span style='font-family: sans-serif; font-size: medium'>%s</span>",
            x)
  } else x
}
```
`r if (knitr:::is_html_output()) '
# Literatur {-}
'`

<!-- --- -->
<!-- nocite: '@Beinke2016' -->
<!-- ... -->

<div id="refs"></div>

<!--chapter:end:20-biblio.Rmd-->

